{"pages":[],"posts":[{"title":"Hibernate简单入门","text":"通过度娘可以知道，Hibernate是一个开放源代码的对象关系映射框架，它对JDBC进行了非常轻量级的对象封装，它将POJO与数据库表建立映射关系，是一个全自动的orm(对象关系映射)框架，hibernate可以自动生成SQL语句，自动执行，使得Java程序员可以随心所欲的使用对象编程思维来操纵数据库。 所谓ORM（英语：Object Relation Mapping，简称ORM，或O/RM，或O/R mapping）是指对象关系映射，是一种程序技术，用于实现面向对象编程语言里不同类型系统的数据之间的转换。对象-关系映射系统一般以中间件的形式存在，主要实现程序对象到关系数据库数据的映射。ORM模型的简单性简化了数据库查询过程。使用ORM查询工具，用户可以访问期望数据，而不必理解数据库的底层结构。简单的说，我们使用ORM可以将我们的对象(POJO)去进行映射，使得我们可以去操作对象就能够完成对表的CRUD操作。 怎么使用Hibernate 开始使用Hibernate通过一个实例来更直观的了解Hibernate框架。 使用Maven直接引用依赖： 12345&lt;dependency&gt; &lt;groupId&gt;org.hibernate&lt;/groupId&gt; &lt;artifactId&gt;hibernate-core&lt;/artifactId&gt; &lt;version&gt;5.4.2.Final&lt;/version&gt;&lt;/dependency&gt; 再导入mysql数据库的驱动包。 创建一个user表 1234567create table h_user( id int primary key auto_increment, name varchar(20), password varchar(20), phone varchar(20), address varchar(50)); 创建实体类 创建一个实体类当做user表的映射。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647public class User { private int id; private String name;//对应表里的name private String password;//对应表里的password private String phone;//对应表里的phone private String address;//对应表里的address public int getId() { return id; } public void setId(int id) { this.id = id; } public String getName() { return name; } public void setName(String name) { this.name = name; } public String getPassword() { return password; } public void setPassword(String password) { this.password = password; } public String getPhone() { return phone; } public void setPhone(String phone) { this.phone = phone; } public String getAddress() { return address; } public void setAddress(String address) { this.address = address; }} 配置Hibernate相关文件 ***.hbm.xml:**它主要用于描述类与数据库中的表的映射关系。 **hibernate.cfg.xml:**它是Hibernate框架的核心配置文件。 User.hbm.xml 详细看注释. 1234567891011121314151617181920212223&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE hibernate-mapping PUBLIC &quot;-//Hibernate/Hibernate Mapping DTD 3.0//EN&quot; &quot;http://www.hibernate.org/dtd/hibernate-mapping-3.0.dtd&quot;&gt;&lt;hibernate-mapping package=&quot;model&quot;&gt; &lt;!-- name:映射实体类的名称 table:映射到数据库里面的表的名称 catalog:数据库名称 --&gt; &lt;class name=&quot;User&quot; table=&quot;h_user&quot; catalog=&quot;hibernateTest&quot;&gt; &lt;!--每个class必须有一个id子元素，用来描述主键--&gt; &lt;id name=&quot;id&quot; column=&quot;id&quot;&gt; &lt;!--生成主键策略--&gt; &lt;generator class=&quot;native&quot;&gt;&lt;/generator&gt; &lt;/id&gt; &lt;!--使用property来描述属性与字段的对应关系，length不写默认为255--&gt; &lt;property name=&quot;name&quot; column=&quot;name&quot; length=&quot;20&quot;&gt;&lt;/property&gt; &lt;property name=&quot;password&quot; column=&quot;password&quot; length=&quot;20&quot;&gt;&lt;/property&gt; &lt;property name=&quot;phone&quot; column=&quot;phone&quot; length=&quot;20&quot;&gt;&lt;/property&gt; &lt;property name=&quot;address&quot; column=&quot;address&quot; length=&quot;20&quot;&gt;&lt;/property&gt; &lt;/class&gt;&lt;/hibernate-mapping&gt; hibernate.cfg.xml 详细看注释。如果使用的是IDEA Maven的项目结构，记得把配置文件放到resources文件夹里，不然找不到相应的xml文件。 123456789101112131415161718192021222324&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE hibernate-configuration PUBLIC &quot;-//Hibernate/Hibernate Configuration DTD 3.0//EN&quot; &quot;http://www.hibernate.org/dtd/hibernate-configuration-3.0.dtd&quot;&gt;&lt;hibernate-configuration&gt; &lt;session-factory&gt; &lt;!--配置数据库连接:驱动、路径、用户、密码--&gt; &lt;property name=&quot;hibernate.connection.driver_class&quot;&gt;com.mysql.jdbc.Driver&lt;/property&gt; &lt;property name=&quot;hibernate.connection.url&quot;&gt;jdbc:mysql://localhost:3306/hibernateTest&lt;/property&gt; &lt;property name=&quot;hibernate.connection.username&quot;&gt;root&lt;/property&gt; &lt;property name=&quot;hibernate.connection.password&quot;&gt;987654zmd&lt;/property&gt; &lt;!--将向数据库发送的SQL语句显示出来--&gt; &lt;property name=&quot;hibernate.show_sql&quot;&gt;true&lt;/property&gt; &lt;!--格式化SQL语句,显示出来的SQL语句会更加可读--&gt; &lt;property name=&quot;hibernate.format_sql&quot;&gt;true&lt;/property&gt; &lt;!--设置方言:HQL语句会翻译成SQL语句--&gt; &lt;property name=&quot;hibernate.dialect&quot;&gt;org.hibernate.dialect.MySQLDialect&lt;/property&gt; &lt;!--配置映射文件所在的位置--&gt; &lt;mapping resource=&quot;model/User.hbm.xml&quot;/&gt; &lt;/session-factory&gt;&lt;/hibernate-configuration&gt; 测试 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788public class HibernateTest { static SessionFactory sessionFactory; static Configuration config; static Session session; public void init(){ config=new Configuration().configure(); sessionFactory=config.buildSessionFactory(); session=sessionFactory.openSession();//相对于得到一个Connec连接 session.beginTransaction();//开启事务 } @Test public void saveTest(){//存储信息 User u=new User(); User u1=new User(); u.setName(&quot;小东&quot;); u.setPassword(&quot;987654zmd&quot;); u.setPhone(&quot;10086&quot;); u.setAddress(&quot;广西&quot;); u1.setName(&quot;小明&quot;); u1.setPassword(&quot;987654&quot;); u1.setPhone(&quot;10010&quot;); u1.setAddress(&quot;广东&quot;); init(); session.save(u); session.save(u1); session.getTransaction().commit();//获取事务并提交 session.close(); sessionFactory.close(); } @Test public void findUserIdTest(){//通过主键获取一个信息 init(); User u=(User) session.load(User.class,1); System.out.println(u.getName()+&quot; &quot;+u.getPassword()+&quot; &quot;+u.getPhone()); session.getTransaction().commit();//获取事务并提交 session.close(); sessionFactory.close(); } @Test public void updateUserTest(){//更新信息 init(); User u=(User)session.load(User.class,1); u.setName(&quot;狗剩&quot;); session.update(u); session.getTransaction().commit(); session.close(); sessionFactory.close(); } @Test public void deleteUserTest(){//通过主键删除一个信息 init(); User u=(User) session.load(User.class,2); session.delete(u); session.getTransaction().commit(); session.close(); sessionFactory.close(); } @Test public void findAllUserTest(){//获取表里的所有信息 init(); //hibernate 中createQuery与createSQLQuery两者区别是： //前者用的hql语句进行查询，后者可以用sql语句查询 //前者以hibernate生成的Bean为对象装入list返回，后者则是以对象数组进行存储 //所以使用createSQLQuery有时候也想以hibernate生成的Bean为对象装入list返回，就不是很方便 //突然发现createSQLQuery有这样一个方法可以直接转换对象 //Query query = session.createSQLQuery(sql).addEntity(XXXXXXX.class); //XXXXXXX 代表以hibernate生成的Bean的对象，也就是数据表映射出的Bean。但是这个bean必须有映射 //Query query=session.createSQLQuery(&quot;select * from h_user&quot;).addEntity(User.class); //项目设置-&gt;Facets -&gt;添加Hibernate检测-&gt; 再给Hibernate添加Hibernate.cfg.xml的配置， // 不然User会报错(因为没有HQL检测，但是可以运行) Query query1=session.createQuery(&quot;from User&quot;); List&lt;User&gt; list=query1.list(); for(User user:list) System.out.println(user.getName()+&quot; &quot;+user.getPassword()); session.getTransaction().commit(); session.close(); sessionFactory.close(); }} 使用单元测试需要引用依赖： 12345&lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.12&lt;/version&gt;&lt;/dependency&gt; 测试存储功能 控制台输出： 数据库： 剩下的功能测试如都无问题，那么我们就算简单入门Hibernate了。","link":"/2019/06/20/Hibernate%E7%AE%80%E5%8D%95%E5%85%A5%E9%97%A8/"},{"title":"JDBC基本步骤","text":"JDBC定义了java与各种SQL数据库之间的编程接口，JDBC API是一个统一的标准应用程序接口，这样可以屏蔽异种数据库之间差异。 JDBC工作原理 JDBC与ODBC(Open Base Connectivity，开放式数据库连接)的作用非常类似，它在应用程序和数据库之间起到桥梁作用。ODBC使用得特别广泛，在java中还提供了JDBC-ODBC桥，能够在JDBC与ODBC之间进行转换，这样可以通过ODBC屏蔽不同种数据库之间的差异。 JDBC编程步骤 1.注册载入JDBC驱动程序 注冊载入驱动driver。也就是强制类载入：其注冊载入JDBC驱动有三种方法： Class.forName(DriverName)； 当中DriverName=Driver包名。Driver类名； Oracle的DriverName=”oracle.jdbc.driver.OracleDriver”。 SQLServer的DriverName=“com.microsoft.jdbc.sqlserver.SQLServerDriver“。 MySql的DriverName=“com.mysql.jdbc.Driver“； 直接创建一个驱动对象: new oracle.jdbc.driver.OracleDriver()。 Class.forName(DriverName).newInstance(); 代码完毕两个功能：第一，把驱动程序载入到内存里；第二。把当前载入的驱动程序自己主动去DriverManager那注冊，DriverManager是JDBC规范中唯一的Java类。 2.得到连接对象Connection 要连接数据库，须要向java.sql.DriverManager请求并获得Connection对象，该对象就代表一个数据库的连接。 使用DriverManager的**getConnectin(Stringurl , String username , String password )**方法. 参数user是指连接数据库时使用的用户名；参数password是指连接数据库时的用户user的登录密码；参数info是作为连接参数的任意字符串标记/值对的列表，通常至少应该包括”user”和”password”属性；参数url是指连接数据库的URL。该方法返回一个连接，一般用一个连接对象接收返回对象。 DriverManager在JDBC规范中是类而不是接口。它是一个服务类，用于管理JDBC驱动程序，提供getConnection()方法建立应用程序与数据库的连接。当JDBC驱动程序载入到内存时，会自己主动向DriverManager注冊。此行代码发出连接请求，DriverManager类就会用注冊的JDBC驱动程序来创建到数据库的连接。 DriverManager.getConnection()是个静态方法。 DriverManager在java.sql包中。当我们调用sql包里不论什么一个类（包含接口）的不论什么一个方法时都会报一个编译时异常SQLException。这里我们使用一个try块后跟多个catch块解决。 12345678private static final String url=&quot;jdbc:mysql://localhost:3306/demo1&quot;;private static final String user=&quot;root&quot;;private static final String password=&quot;987654zmd&quot;;try { Connection con = DriverManager.getConnection(url, user, password); } catch (SQLException e) { e.printStackTrace(); } 常用的数据库软件的url写法： Oracle: jdbc:oracle:thin:@ip:1521:dbName； MySql：jdbc:mysql://ip:3306:dbName； SQLServer：jdbc:sqlserver://ip:1443;databaseName=dbName； 当使用本机ip地址连接时须要关闭防火墙。否则连接不上，使用localhost或127.0.0.1则不用关闭防火墙。 3.创建 Statement对象1、运行静态SQL语句。通常通过Statement实例实现。 2、运行动态SQL语句。通常通过PreparedStatement实例实现。 3、运行数据库存储过程。通常通过CallableStatement实例实现。 详细实现方式： Statement stmt = con.createStatement(); PreparedStatement pstmt=con.prepareStatement(sql); CallableStatement cstmt =con.prepareCall(“{CALLdemoSp(? , ? )}”) ; ４.运行sql语句 Statement接口提供了三种运行SQL语句的方法：executeQuery、executeUpdate 和execute ResultSet executeQuery(String sqlString)： 运行查询数据库的SQL语句。返回一个结果集（ResultSet）对象。 int executeUpdate(String sqlString)： 用于运行INSERT、UPDATE或DELETE语句以及SQL DDL语句，如：CREATETABLE和DROP TABLE等 execute(sqlString): 用于运行返回多个结果集、多个更新计数或二者组合的 语句。详细实现的代码： ResultSet rs = stmt.executeQuery(“SELECT * FROM …”) ; int rows = stmt.executeUpdate(“INSERTINTO …”) ; boolean flag =stmt.execute(String sql) ; 5.处理结果 两种情况 运行更新返回的是本次操作影响到的记录数。 运行查询返回的结果是一个ResultSet对象。 ResultSet包括符合SQL语句中条件的全部行。而且它通过一套get方法提供了对这些行中数据的訪问。使用结果集（ResultSet）对象的訪问方法获取数据： 1234567while(rs.next()){ String name = rs.getString(&quot;name&quot;) ; String pass = rs.getString(1) ; // 此方法比較高效 } 6.关闭资源释放资源 操作完毕以后要把全部使用的JDBC对象全都关闭，以释放JDBC资源。关闭顺序和声明顺序相反： 关闭记录集 关闭声明 关闭连接对象 123456789101112131415161718192021222324public static void close(Connection con, Statement pstmt, ResultSet rs) { try { if (rs != null) { // 关闭记录集 rs.close(); rs = null; } } catch (SQLException e) { e.printStackTrace(); } finally { try { if (pstmt != null) { pstmt.close();// 关闭声明 pstmt = null; } } catch (SQLException e) { e.printStackTrace(); } finally { if (con != null) { con.close();// 关闭连接对象 } } } }} 一个简单的框架 1.Pools.java1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162import java.sql.Connection;import java.sql.DriverManager;import java.sql.SQLException;import java.util.LinkedList;/** * 小型项目可以使用该连接池，如果涉及到大型项目，应该使用专业的是数据库连接池管理工具。 * C3P0 * */public class Pools { private static final String url=&quot;jdbc:mysql://localhost:3306/demo1&quot;; private static final String driver=&quot;com.mysql.jdbc.Driver&quot;; private static final String user=&quot;root&quot;; private static final String password=&quot;987654zmd&quot;; private static Connection con = null; private static LinkedList&lt;Connection&gt; pool = new LinkedList&lt;Connection&gt;(); static { try { Class.forName(driver); for(int i = 0 ; i &lt; 10 ; i++) { //往连接池中追加数据库连接 pool.addLast(getPoolConnection()); } } catch (ClassNotFoundException e) { e.printStackTrace(); } } /** * 创建连接尺寸装载数据库连接 * @return */ public static Connection getPoolConnection() { try { con = DriverManager.getConnection(url, user, password); } catch (SQLException e) { e.printStackTrace(); } return con; } /** * 从连接池中取出连接 * @return */ public static Connection getConnection() { con = pool.removeFirst(); return con; } /** * 把使用之后的数据库连接放回连接池中 * @param con */ public static void free(Connection con) { pool.addLast(con); }} 2.DBUtils1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950import java.sql.Connection;import java.sql.ResultSet;import java.sql.SQLException;import java.sql.Statement;public class DBUtils extends Pools { private static Connection con = null; /** * 获取数据库连接 * * @return */ public static Connection getDBUtilsConnection() { con = getConnection(); return con; } /** * 关闭顺序 rs -- pstmt --con * * @param con * @param pstmt * @param rs */ public static void close(Connection con, Statement pstmt, ResultSet rs) { try { if (rs != null) { rs.close(); rs = null; } } catch (SQLException e) { e.printStackTrace(); } finally { try { if (pstmt != null) { pstmt.close(); pstmt = null; } } catch (SQLException e) { e.printStackTrace(); } finally { if (con != null) { free(con); } } } }} 3.SqlExecute1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071import java.sql.Connection;import java.sql.PreparedStatement;import java.sql.ResultSet;import java.sql.SQLException;public class SqlExecute extends DBUtils { private static Connection con = null; private static PreparedStatement pstmt = null; /** * insert update delete * @param sql * @param objects * @return */ public boolean sqlExecuteUpdate(String sql, Object[] objects) { boolean b = false; con = getDBUtilsConnection(); try { pstmt = con.prepareStatement(sql); if (objects != null) { for (int i = 0; i &lt; objects.length; i++) { pstmt.setObject(i + 1, objects[i]); } } int row = 0; row = pstmt.executeUpdate(); if (row &gt; 0) { b = true; } } catch (SQLException e) { e.printStackTrace(); }finally { close(con, pstmt, null); } return b; } /** * select * @param sql * @param objects * @return */ public ResultSet sqlExecutteQuery(String sql , Object[] objects) { con = getDBUtilsConnection(); ResultSet rs = null; try { pstmt = con.prepareStatement(sql); if(objects != null) { for(int i = 0 ; i &lt; objects.length ; i++) { pstmt.setObject(i + 1, objects[i]); } } rs = pstmt.executeQuery(); } catch (SQLException e) { e.printStackTrace(); } return rs; } /** * 关闭已经使用结束后的数据集 * @param rs */ public void close(ResultSet rs) { close(con, pstmt, rs); }} ps:一个老师写的，先放在这里吧","link":"/2019/05/07/JDBC%E5%9F%BA%E6%9C%AC%E6%AD%A5%E9%AA%A4/"},{"title":"JSP-指令","text":"1.page指令 language language定义页面使用的脚本语言，默认情况下值为java，因此在编写JSP程序时，此属性不必设置。 import import属性是常用的。它用来导入程序中要用的包和类，此属性可以有多个值。无论是java核心包中自带类还是客户自行编写的类，都要在import中引用，这样才能在JSP程序中使用这个类。 contentType contentType属性设置JSP页面的MIME类型。设置类型的格式为”MIME类型”或”MIME类型；charset=编码”。在JSP页面默认情况下设置字符编码为ISO-8859-1，即type=”text/html;charset=ISO-8859-1”。 session session属性设置在JSP页面中是否需要使用session对象。如果为false，则在JSP程序中不能使用session对象以及scope=session的javaBean或EJB。此属性默认值为true。 buffer buffer的值可以有none、8kb或是给定的kb值，值为none表示没有缓存，直接输出至客户端的浏览器中，此属性用来设定out对象缓存处理的缓冲区的大小。 autoFlash autoFlash属性设置当缓冲区已满时，是否自动刷新缓冲区。如果取值为false，当缓冲区溢出时就会出现异常；当buffer的值为none时，此属性的值不能为false。此属性的默认值为true。 isThreadSafe isThreadSafe属性设置JSP页面是否可以多线程访问。如果值为true则此JSP页面可同时响应多个客户的请求；如果为false则在某个时刻内只能处理一个客户的请求。此属性的默认值为true。 info info属性设置JSP页面的信息字符串，可以是针对本JSP页的一些说明性文字，可用getServletInfo()方法来获得这个字符串。为什么会是getServletInfo()呢？因为JSP引擎实际上是把JSP转换为Servlet后再响应客户端的请求。 errorPage errorPage属性设置出现异常时转向页面的URL。 isErrorPage isErrorPage属性设置是否为出错页面。如果为true则可以exception对象，如果为false则不行。默认情况下是false，故在需要使用exception对象的JSP页面中要注意在page指令中设置此属性的值为true。 2.include指令 include指令用来在该指令处静态插入一个文件，这与C语言中的#include类似，它只是把文件代码与文本件组合起来形成一个大的程序文件。include指令调用的语法格式如下。 1&lt;%@ include file=&quot;文件路径&quot;%&gt; JSP动作指令1.include动作指令 include动作指令用来在JSP页面中动态包含一个文件，这样包含页面程序与被包含页面的程序是彼此独立的，互不影响。ps:include动作指令与include指令不同，后者是静态包含，将包含文件与被包含文件组合形成一个文件；而前者是动态包含，原理不同，使用时也会有差别。使用格式如下: 1&lt;jsp: include page=&quot;文件路径&quot;/&gt; 2.forward动作指令 forward动作指令用来重定向网页，即从当前网页的forward动作指令处转向执行另一个网页程序。forward动作指令的调用语法格式如下: 1&lt;jsp:forward page=&quot;文件路径&quot;/&gt; 3.param动作指令 在前面的include动作指令和forward动作指令中均出现了param动作指令，它用来向需要包含的动态页面或要转向的动态页面传递参数。 4.plugin动作指令 这个动作指令用来在JSP中加载Java applet小程序。用&lt; applet &gt;…&lt; /applet &gt;也可以使客户端下载并运行Java applet小程序，但有的浏览器不支持，如IE5.5就不支持JDK1.2以上版本的类，如果Java applet小程序使用了这样的类，将无法执行。用plugin动作指令可以较好地解决这个问题，运行Java applet小程序的插件由客户端来下载。语法如下： 12345&lt;jsp:plugin type=&quot;applet&quot; code=&quot;小程序的类文件&quot; codebase=&quot;小程序所在的位置&quot; jreversion=&quot;虚拟机版本号&quot; width=&quot;小程序显示宽度&quot; heigth=&quot;小程序显示高度&quot;&gt; &lt;jsp:fallback&gt; 客户端浏览器是否支持插件下载的提升信息 &lt;/jsp:fallback&gt;&lt;/jsp:plugin&gt; 5.useBean动作指令 这是一个非常重要的动作指令，用来在JSP中创建并使用一个JavaBean。实际工程中常用JavaBean做组件开发，而在JSP中只需要声明并使用这个组件，这样可以较大限度地实现静态内容和动态内容的分离，这也是JSP的优点之一。语法格式如下: 12&lt;jsp:useBean id=&quot;bean的名称&quot; scope=&quot;有效范围&quot; class=&quot;包名.类名&quot;&gt;&lt;/jsp:useBean&gt; 6.setProperty动作指令 这个动作指令用来设置Bean中属性的值，基本语法格式有如下四种: 1234&lt;jsp:setProperty name=&quot;bean的名称&quot; property=&quot;*&quot;/&gt;&lt;jsp:setProperty name=&quot;bean的名称&quot; property=&quot;属性名称&quot;/&gt;&lt;jsp:setProperty name=&quot;bean的名称&quot; property=&quot;属性名称&quot; param=&quot;参数名称&quot;/&gt;&lt;jsp:setProperty name=&quot;bean的名称&quot; property=&quot;属性名称&quot; value=&quot;属性值&quot;/&gt; 7.getProperty动作指令 getProperty动作指令用来获得bean的属性并将其转换为字符串，再在JSP页面中输出。使用的语法格式如下: 1&lt;jsp:getProperty name=&quot;bean的名称&quot; property=&quot;属性名称&quot;&gt; JSP中的中文字符处理12345678910public String codeToString(String str){ String s=str; try{ byte temp[]=s.getBytes(&quot;ISO-8859-1&quot;); s=new String(temp); return s; }catch (Exception e){ return s; }}","link":"/2019/05/04/JSP%E6%8C%87%E4%BB%A4/"},{"title":"PCA与SVD","text":"最近接触到了PCA与SVD经过网上查找资料简单理解后，在此记录总结一下。 SVD 奇异值分解是一个有着很明显的物理意义的一种方法，它可以将一个比较复杂的矩阵用更小更简单的几个子矩阵的相乘来表示，这些小矩阵描述的是矩阵的重要的特性。一个矩阵可以分解为两个方阵和一个对角矩阵的乘积。 对于一个M × N的矩阵A，我们想要分解成如下的形式： 其中，U称为左奇异矩阵，V称为右奇异矩阵， Σ 仅在对角线上有值，我们称它为奇异值，其他的元素均为0。每个矩阵的维度如下： 举个栗子，SVD用于图像压缩 原图： 一只可爱的猫咪 代码: 1234567891011121314151617import numpy as npimport matplotlib.pyplot as pltfrom PIL import Image plt.style.use('classic')img = Image.open('猫咪.jpg')imggray = img.convert('L') # 转化成灰度图片imgmat = np.array(list(imggray.getdata(band = 0)), float)# 转化成数组形式imgmat.shape = (imggray.size[1], imggray.size[0]) # 更换数组形态(m,n)u, d, v = np.linalg.svd(imgmat) #奇异值分解得到三个矩阵 u = (m,m) d = (m,n) v = (n,n)print(&quot;u: &quot;,u.shape,&quot; d: &quot;,d.shape,&quot; v: &quot;,v.shape)for i in [5, 10, 15, 20, 30, 50, 100, 200, 374]: # 使用 多少个奇异值 reconstimg = np.dot(u[:,:i] * d[:i], v[:i,:]) #u = (m,i) d = (i,i) v = (i,n) 部分奇异值分解 A(m,n) = u(m,i) * d(i,i) * v(i,n) plt.imshow(reconstimg, cmap='gray') t = &quot;n = %s&quot; % i plt.title(t) plt.show() 分解得到的三个矩阵的维度： d则是svd函数得到的奇异值，从大到小排序。 使用5个奇异值： 很模糊。 使用15个奇异值： 整体大致可以看清楚了 使用50个奇异值: 当使用50个奇异值时，已经和原图没有多大的差别了。所以，奇异值可以代表矩阵的信息，当奇异值越大时，它代表的信息越多。因此，我们取前面若干个最大的奇异值，基本就可以还原数据本身了。 PCA PCA（Principal Component Analysis）是一种常用的数据分析方法。PCA通过线性变换将原始数据变换为一组各维度线性无关的表示，可用于提取数据的主要特征分量，常用于高维数据的降维。 定义 PCA是将n维特征映射到k维上（k&lt;n），这k维是全新的正交特征。这k维特征称为主成分，是重新构造出来的k维特征，而不是简单地从n维特征中去除其余n-k维特征。 基本步骤以及代码实现 这里主要讲一下PCA的基本步骤以及代码实现，至于分析过程以及原理就不讲了，还没研究得那么深，，， 对数据进行归一化处理。通常做法是去均值处理 生成10个样本，每个样本拥有4个特征并做去均值处理 123456789101112131415import numpy as nptest = [[2.5, 0.5, 2.2, 1.9, 3.1, 2.3, 2, 1, 1.5, 1.1], [2.4, 0.7, 2.9, 2.2, 3.0, 2.7, 1.6, 1.1, 1.6, 0.9], [1.3, 2.3, 2.1, 0.8, 1.4, 1.2, 2.1, 0.4, 0.7, 2.7], [1.8, 0.5, 0.1, 1.8, 2.4, 4.2, 1.1, 0.4, 1.7, 0.7] ]test_mat = np.matrix(test).Ttest_mean = np.mean(test,axis=1)#axis=0表示按照列来求均值，如果输入list,则axis=1m, n = np.shape(test_mat)avgs = np.tile(test_mean, (m, 1))#将avgs拉伸成(m,n)data_adjust = test_mat - avgsprint(m,n)print(test_mat)print(&quot;每列的均值 :&quot;,test_mean)print(data_adjust) 求特征协方差矩阵 在概率论和统计中，协方差是对两个随机变量联合分布线性相关程度的一种度量。协方差大于0表示x和y若一个增，另一个也增；小于0表示一个增，一个减。如果x和y是统计独立的，那么二者之间的协方差就是0；但是协方差为0，并不能说明x和y是独立的。协方差绝对值越大，两者对彼此的影响越大，反之越小。其定义如下： ​ 对于多维随机变量，我们往往需要计算各维度两两之间的协方差，这样各协方差组成了一个 n × n的矩阵，称为协方差矩阵，它是一个对称矩阵。当X,Y是同一个随机变量时，X与其自身的协方差就是X的方差，可以说方差是协方差的一个特例。 对角线上的元素即为各维度上变量的方差。因为我们的数据拥有4的特征，所以协方差矩阵为[4,4]。 12covX = np.cov(data_adjust.T) #计算协方差矩阵print(&quot;协方差矩阵为：\\n&quot;,covX) **求协方差的特征值和特征向量并将特征值按照从大到小的顺序排序 ** 12345featValue, featVec= np.linalg.eig(covX) #求解协方差矩阵的特征值和特征向量print(&quot;特征值为:&quot;,featValue)print(&quot;特征向量为:\\n&quot;,featVec)index = np.argsort(-featValue) #按照featValue进行从大到小排序,并返回下标print(index) 将样本点投影到选取的特征向量上 假设样本数为m，特征数为n，减去均值后的样本矩阵为DataAdjust(m * n)，协方差矩阵是n * n，选取的k个特征向量组成的矩阵为EigenVectors(n * k)。 将上面的n维特征变成k(k &lt; n)维。 123456789k = int(input(&quot;输入k的值&quot;))if k &gt; n: print(&quot;k的值应该小于n&quot;)else: #注意特征向量时列向量，而numpy的二维矩阵(数组)a[m][n]中，a[1]表示第1行值 selectVec = np.matrix(featVec.T[index[:k]]) #所以这里需要进行转置 finalData = data_adjust * selectVec.Tprint(&quot;原矩阵：\\n&quot;,test_mat)print(&quot;投影后的数据: \\n&quot;,finalData) k = 2： 这样，就将原始样例的4维特征变成了2维，这2维就是原始特征在2维上的投影。","link":"/2019/11/04/PCA%E4%B8%8ESVD/"},{"title":"SQL基础语法","text":"新建表 其中，tablename是要建立表的名称；column_name1是建立表中列的名称，即字段名；datatype是这个字段的数据类型；column_constraint是字段的约束规则，如:主键约束、外键约束。 12345create table tablename( column_name1 datatype [column_constraint], column_name2 datatype [column_constraint], ...) 如： 1234567891011create table usertable( user_id bigint IDENTITY (1,1) not null primary key,//IDENTITY (1,1)表示自动增加，增加值为1 user_name varchar(40), user_password varchar(40), user_true_name varchar(40),//用户的真实姓名 user_age int, user_sex varchar(2), user_address varchar(80), user_telephone varchar(20), user_time datetime default (gerdate())) 删除表1drop table table_name 更改表1234alter table table_name[alter column column_name new_datatype [column_constraint]]|[add column_name new_datatype [column_constraint]]|[drop column_name new_datatype [column_constraint]] 查询语句 在SQL语句中，查询语句select是最为常用的，其基本的语法格式如下。 123456select select_list [into new_table]from table_source[where search_condition][group by group_by_expression][having search_condition][order by order_expression [ASC|DESC]] 其中，select_list是要查询的内容，如：字符名称的列表；[into new_table]是指可以把查询的结果放入一个新的表中；table_source是指表名，是查询数据的来源，如果是单表查询则为一个表的名称，如为多表查询则是表的名称列表；search_condition是查找的条件；group_by_expression是查询结果分组的条件；search_condition中分组后组内的条件；order_expression[ASC|DESC]是指排序的表达式以及方式，如：order_expression可以是一个字段名，则根据这个字段来排序，ASC表示升序，DESC表示降序。 比如： 在userTable中要找出年龄在20~30岁之间的用户信息，并按ID号升序排序： 123select * from userTable where user_age&gt;10 and user_age&lt;30 order by user_id asc 1.=号 如果数据类型是数值型则不必用引号(‘或(“括起来，如果是字符型，则必须用引号括起来，如： 12select * from userTable where user_age=20 and user_name='yourname' 其功能是从user_Table表中查找出年龄是20，姓名是yourname的记录。 2.in与not in in用来确定给定的值是否与子查询或列表中的值相匹配，使用not in则对返回值相反。其语法格式如下： 12345test_expression [NOT] IN( subquery |expression [,...n]) 其中test_expression是一个有效的表达式；subquery是包含某列结果集的子查询，必须与test_expression具有相同的类型；expression [,…n]是一个表达式列表，用来测试是否匹配，所有表达式必须和test_expression具有相同的类型。 如：查询出年龄是20、22、25的用户信息 12select * from userTable where user_age in (20,22,25) 3.between…and与not between…and between…and用来选择列值在某个范围内的记录，not between…and则恰恰相反，用来选择列值不在某个范围内的记录，其语法如下： 1test_expression [NOT] between begin_expression and end_expression 如：查询出年龄在20~25(包括20岁和25岁)岁之间的用户信息 12select * from userTable where user_age between 19 and 26 4.like与no like 确定给定的字符串是否与指定的模式匹配。模式可以包含常规字符和通配符字符，可使用字符串的任意片段匹配通配符。与使用”=”和”！=”字符串比较运算符相比，使用通配符可使LIKE运算符更加灵活。语法如下： 1match_expression [NOT] like pattern 其中，match_expression是任何字符串数据类型的有效表达式，pattern是在match_expression中的搜索模式，可有如下的通配符:”%”表示包含零个或更多字符的任意字符串；”_”表示任意单个字符。通配符在各种数据库可能会不一样。这里只介绍SQL Server的通配符。 如：查询出真实姓名为姓”邓”的用户信息 12select * from userTable where user_true_name like '邓%' 5.in null与is not null is null确定一个给定的表达式是否为null，in not null与is null相反。其语法如下： 1expression is [not] null 其中expression是一个有效的表达式 如：查询出真实姓名是空的用户信息 12select * from usetTable where user_true_name is null 6.and与or and运算用来连接两个布尔型表达式并当两个表达式都为true时返回false or运算用来将两个条件结合起来，满足其中之一即返回true and运算的优先级比or要高 插入语句12insert into table_name(column_name1,column_name2,...) value(column_name1_values,column_name2_values,...) 其中，table_name是将行添加到数据表中；(column_name1,column_name2,…)是要添加内容的列；(column_name1_values,column_name2_values,…)是将要插入的单个列中对应的值或表达式。 如：要往用户表中插入一条用户信息记录 12insert into table_name(user_name,user_password,user_true_name,user_age,user_sex,user_address,user_telephone) value('zmd','987654','翟',18,'男','桂林','10086') 其中表的user_id和add_time字段的值可以自动生成。 更新12345update table_name set column_name1=column_name1_values, column_name2=column_name2_values, ... [where 子句] 其中，where子句同select语句中的where子句 如:把用户表真实姓名姓邓的年龄全部改为27。 12update userTable set user_age=27 where user_true_name like'邓%' 删除1delete from table_name [where 子句] where子句同select语句中的where子句 如：删除用户表中姓邓的用户的所有记录 1delete from userTable where user_true_name like'邓%' 查看所有数据库1show databases;","link":"/2019/05/06/SQL%E7%9A%84%E4%B8%80%E4%BA%9B%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/"},{"title":"Spring-Bean的获取","text":"要使应用程序中的Spring容器成功启动，需要同时具备以下3方面的条件： Spring框架的类包都已经放到应用程序的类路径下。 应用程序为Spring提供完备的Bean配置信息。 Bean的类都已经放到应用程序的类路径下。 Spring通过一个配置文件描述了Bean及Bean之间的依赖关系，利用Java语言的反射功能实例化Bean并建立Bean之间的依赖关系。Spring的IoC容器在完成这些底层工作的基础上，还提供了Bean实例缓存、生命周期管理、Bean实例代理、事件发布、资源装载等高级服务。 Spring启动时读取应用程序提供的Bean配置信息，并在Spring容器中生成一份相应的Bean配置注册表，然后根据这张注册表实例化Bean，装配好Bean之间的依赖关系，为上层应用提供准备就绪的运行环境。 Bean配置信息是Bean的元数据信息，它由以下4个方面组成。 Bean的实现类。 Bean的属性信息，如数据源的连接数、用户名、密码等。 Bean的依赖关系，Spring根据依赖关系配置完成Bean之间的装配。 Bean的行为配置，如生命周期范围及生命周期各过程的回调函数等。 它们的相互关系，如下 BeanFactory 诚如其名，BeanFactory是一个类工厂，但它和传统的类工厂不同，传统的类工厂仅负责构造一个或几个类的实例，而BeanFactory是类的通用工厂，他可以创建并管理各种类的对象。 通过BeanFactory获取Beanbeans.xml Cat的配置文件 1234567891011121314151617&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:p=&quot;http://www.springframework.org/schema/p&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt; &lt;bean id=&quot;c&quot; class=&quot;com.smart.model.Cat&quot; p:weigth=&quot;50&quot; p:age=&quot;4&quot; p:color=&quot;白色&quot; /&gt; &lt;bean id=&quot;c2&quot; class=&quot;com.smart.model.Cat&quot; p:weigth=&quot;40&quot; p:color=&quot;橘色&quot; p:age=&quot;2&quot; /&gt; &lt;bean class=&quot;com.smart.model.Cat&quot;/&gt;&lt;/beans&gt; test类 1234567891011121314151617import com.smart.model.Cat;import org.springframework.beans.factory.BeanFactory;import org.springframework.beans.factory.xml.XmlBeanFactory;import org.springframework.core.io.Resource;import org.springframework.core.io.support.PathMatchingResourcePatternResolver;import org.springframework.core.io.support.ResourcePatternResolver;public class test1 { public static void main(String[] args) { ResourcePatternResolver resolver=new PathMatchingResourcePatternResolver(); Resource res=resolver.getResource(&quot;classpath:beans/cat.xml&quot;); BeanFactory bf=new XmlBeanFactory(res); System.out.println(&quot;使用XmlBeanFactory启动Spring容器&quot;); Cat c=bf.getBean(&quot;c&quot;, Cat.class); System.out.println(c.getAge()+&quot; &quot;+c.getColor()+&quot; &quot;+c.getWeigth()); }} 结果 XmlBeanFactory通过Resource装载Spring配置信息并启动IoC容器，然后就可以通过BeanFactory #getBean(beanName)方法从IoC容器中获取Bean了。通过BeanFactory启动IoC容器时，并不会初始化配置文件中定义的Bean。 通过ApplicationContext获取Bean ApplicationContext由BeanFactory派生而来，提供了更多面向实际应用的功能。在BeanFactory中，很多功能需要以编程的方式实现，而在ApplicationContext中则可以通过配置的方式实现。 在获取ApplicationContext实例后，就可以像BeanFactory一样调用getBean(beanName)返回Bean了。 配置文件放置在类路径下 优先使用ClassPathXmlApplicationContext实现类. 1ApplicationContext ctx=new ClassPathXmlContext(&quot;路径&quot;); 配置文件放置在文件系统的路径下 可以考虑优先使用FilySystemXmlApplicationContext实现类 1ApplicationContext ctx=new FilySystemXmlApplicationContext(&quot;路径&quot;); 指定一组配置文件 1ApplicationContext ctx=new ClassPathXmlApplicationContext(new String[]{&quot;路径1&quot;,&quot;路径2&quot;}); 类注解配置(@Configuration) 使用AnnotationConfigApplicationContext实现类 1ApplicationContext ctx=new AnnotationConfigApplicationContext(&quot;路径&quot;); 示例 123456public static void main(String[] args) { ApplicationContext ctx=new ClassPathXmlApplicationContext(&quot;beans/cat.xml&quot;); Cat c=ctx.getBean(&quot;c&quot;, Cat.class); System.out.println(&quot;使用ClassPathXmlApplicationContext启动Spring容器&quot;); System.out.println(c.getAge()+&quot; &quot;+c.getColor()+&quot; &quot;+c.getWeigth()); } PS:使用的是IDEA，需要注意路径，xml配置文件要放在resources文件夹里中不要放在java文件夹里 它们的区别 ApplicationContext的初始化和BeanFactoy的初始化有一个重大的区别：BeanFactey在初始化容器 时，并未实例化Bean，直到第一次访问某个Bean时才实例化目标Bean；而ApplicationContext在初始化应用上下文时就实例化所有单实例的Bean。因此ApplicationContext的初始化时间会比BeanFactey稍长一些。","link":"/2019/06/08/Spring-Bean%E7%9A%84%E8%8E%B7%E5%8F%96/"},{"title":"Spring-Bean的配置","text":"配置Bean一共有三种方式 基于XML文件配置 基于注解配置 基于Java类配置 不管是哪种配置，都是表达Bean定义的载体，其实本质都是为Spring容器提供Bean定义的信息。它们允许多项组合。 1.基于XML文件配置 下面基于XML配置文件定义了三个简单的Bean 12345678&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt; &lt;bean id=&quot;cat&quot; class=&quot;com.smart.model.Cat&quot;/&gt; &lt;bean id=&quot;dog&quot; class=&quot;com.smart.model.Dog&quot;/&gt; &lt;bean id=&quot;people&quot; class=&quot;com.smart.model.People&quot;/&gt;&lt;/beans&gt; 这段信息提供了实例化Cat、Dog、People这三个Bean的必需信息，IoC容器完全可以根据此创建这三个Bean的实例。 测试 1234567891011public class test4 { public static void main(String[] args) { ApplicationContext ct=new ClassPathXmlApplicationContext(&quot;beans/beans.xml&quot;); Cat c=ct.getBean(&quot;cat&quot;,Cat.class); Dog d=ct.getBean(&quot;dog&quot;,Dog.class); People p=ct.getBean(&quot;people&quot;,People.class); if (c!=null&amp;&amp;d!=null&amp;&amp;p!=null){ System.out.println(&quot;IoC容器启动成功！！&quot;); } }} 输出： 配置文件中不允许出来id相同的Bean，但可以出现相同name的Bean，如果有多个相同name的Bean，则返回最后声明的Bean，因为后面声明的Bean将前面的覆盖了。 2.基于注解的配置下面使用注解定义Bean peopleBean 声明一个id=people1的Bean，Spring通过@Autowired注解实现Bean的依赖注入，@Autowried的required属性表示当在容器里找不到匹配的Bean时也不会抛出异常(默认为true，找不到会抛出异常)。@Qualifier为指定注入Bean，如果容器有一个以上匹配的Bean，则可以通过@Qualifier注解限定Bean的名称。 1234567891011121314151617181920212223242526272829303132333435363738import org.springframework.beans.factory.annotation.Autowired;import org.springframework.beans.factory.annotation.Qualifier;import org.springframework.stereotype.Component;@Component(&quot;people1&quot;)public class peopleBean { private String name; private catBean cat; @Autowired @Qualifier(&quot;dog1&quot;) private dogBean dog; public catBean getCat() { return cat; } @Autowired(required = false) public void setCat(catBean cat) { this.cat = cat; } public String getName() { return name; } public void setName(String name) { this.name = name; } public dogBean getDog() { return dog; } public void setDog(dogBean dog) { this.dog = dog; }} catBean 声明一个id=cat1的Bean 1234567891011121314151617181920212223import org.springframework.stereotype.Component;@Component(&quot;cat1&quot;)public class catBean { private String name; private int age; public String getName() { return name; } public void setName(String name) { this.name = name; } public int getAge() { return age; } public void setAge(int age) { this.age = age; }} dogBean 声明一个id=dog1的Bean 1234567891011121314151617181920212223import org.springframework.stereotype.Component;@Component(&quot;dog1&quot;)public class dogBean { private String name; private int age; public String getName() { return name; } public void setName(String name) { this.name = name; } public int getAge() { return age; } public void setAge(int age) { this.age = age; }} 配置文件 使用context命名空间，它提供了通过扫描类包以应用注解定义Bean的方式。通过context命名空间的component-scan的base-package的属性指定一个需要扫描的基类包。 1234567891011&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot;//声明命名空间 xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd&quot;&gt; &lt;!--扫描com.smart.Beans 类包里定义的Bean--&gt; &lt;context:component-scan base-package=&quot;com.smart.Beans&quot;/&gt; &lt;/beans&gt; 如果仅希望扫描特定的类而并非基类包下的所有类，那么可以使用resource-pattern属性过滤出特定的类。如： 1&lt;context:component-scan base-package=&quot;com.smart&quot; resource-pattern=&quot;Beans/*.class&quot;/&gt; Spring仅会扫描基类包里Beans子包中的类。 测试类Test 1234567891011121314151617import com.smart.Beans.peopleBean;import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;public class test4 { public static void main(String[] args) { ApplicationContext ct=new ClassPathXmlApplicationContext(&quot;beans/component.xml&quot;); peopleBean p=ct.getBean(&quot;people1&quot;,peopleBean.class); if (p!=null&amp;&amp;p.getDog()!=null&amp;&amp;p.getCat()!=null){ System.out.println(&quot;IoC容器启动成功！！&quot;); p.setName(&quot;老GS&quot;); p.getCat().setName(&quot;小菊&quot;); p.getDog().setName(&quot;旺财&quot;); System.out.println(p.getName()+&quot;的Cat叫&quot;+p.getCat().getName()+&quot;,Dog叫&quot;+p.getDog().getName()); } }} 结果： 除了@Component以外,Spring提供了如下3个功能基本和@Component等效的注解，它们分别用于对DAO、Service、及Web层的Controller进行注解，所以也称这些注解为Bean的衍型注解。 @Repository: 用于对DAO实现类进行标注 @Service: 用于对Service实现类进行标注 @Controller: 用于对Controller实现类进行标注 提供这3个特殊的注解是为了让注解类本身的用途清晰化，此外Spring也赋予它们一些特殊的功能。 3.基于Java类的配置 普通的POJO(简单Java对象)只要标注**@Configuration**注解，就可以为Spring容器提供Bean定义的信息了，每个标注了@Bean的类方法都相对于提供一个Bean的定义信息。 peopleConfig 在PeopleConfig类定义处标注@Configuration注解，说明这个类可用于为Spring提供Bean的定义信息。类的方法处可以标注@Bean注解，Bean的类型由方法返回值类型决定，名称默认和方法名相同。由于@ Configuartion注解类本身已经标注了@Component注解，所以任何标注了@Configuration的类，它们可以像普通的Bean一样被注入其他的Bean中。如下面将AnimalConfig注入其中。 1234567891011121314151617181920import org.springframework.beans.factory.annotation.Autowired;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import org.springframework.context.annotation.Import;@Configuration@Import(AnimalConfig.class)public class PeopleConfig { @Autowired private AnimalConfig animalConfig;//像普通的Bean一样注入 @Bean public People getPeople(){ People people=new People(); people.setC(animalConfig.peopleCat()); people.setD(animalConfig.peopleDog()); return people; }} AnimalConfig 定义AnimalConfig配置类。给第一个Bean命名为cat1。@Scope表示每次调用peopleDog都会返回一个新的Bean。 1234567891011121314151617import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import org.springframework.context.annotation.Scope;@Configurationpublic class AnimalConfig { @Bean(name=&quot;cat1&quot;) public Cat peopleCat(){ return new Cat(); } @Scope(&quot;prototype&quot;) @Bean public Dog peopleDog(){ return new Dog(); }} 通过@Configuration类启动IoC容器 通过AnnotationConfigApplicationContext类的构造函数直接传入标注@Configuration的Java类，直接用该类中提供的Bean定义信息启动IoC容器。 12345678910111213141516171819import com.smart.config.PeopleConfig;import org.springframework.context.ApplicationContext;import org.springframework.context.annotation.AnnotationConfigApplicationContext;public class test5 { public static void main(String[] args) { ApplicationContext ct= new AnnotationConfigApplicationContext(PeopleConfig.class); People p=ct.getBean(People.class); Cat c=ct.getBean(&quot;cat1&quot;,Cat.class); Dog d=ct.getBean(&quot;peopleDog&quot;,Dog.class); if (p!=null&amp;&amp;p.getD()!=null&amp;&amp;p.getC()!=null&amp;&amp;c!=null&amp;&amp;d!=null){ System.out.println(&quot;基于Java类配置Bean，IoC容器启动成功！！&quot;); p.setName(&quot;老GS&quot;); p.getC().setName(&quot;小菊&quot;); p.getD().setName(&quot;旺财&quot;); System.out.println(p.getName()+&quot;的Cat叫&quot;+p.getC().getName()+&quot;,Dog叫&quot;+p.getD().getName()); } }} 由于在PeopleConfig配置类中用@Import(AnimalConfig.class)将AnimalConfig配置类组装起来了，所以直接加载PeopleConfig.class就行了。如果没有组装需要如下操作： 123456AnnotationConfigApplicationContext ct= new AnnotationConfigApplicationContext();//加载多个@Configuration配置类ct.register(PeopleConfig.class);ct.register(AnimalConfig.class);//刷新容器以应用这些注册的配置类ct.refresh(); 结果： 通过XML配置文件引用@Configuration的配置1234567891011&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd&quot;&gt; &lt;!--通过上下文扫描加载到PeopleConfig的配置类--&gt; &lt;context:component-scan base-package=&quot;com.smart.config&quot; resource-pattern=&quot;PeopleConfig&quot;/&gt;&lt;/beans&gt; 通过@Configuration配置类引用XML配置信息 如下面xml中定义了三个Bean。 123456789&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:p=&quot;http://www.springframework.org/schema/p&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt; &lt;bean class=&quot;com.smart.model.Dog&quot;/&gt; &lt;bean class=&quot;com.smart.model.People&quot;/&gt; &lt;bean class=&quot;com.smart.model.Cat&quot;/&gt;&lt;/beans&gt; 在@Configuration配置类中可通过@ImportResource引入XML配置文件，在配置类中即可直接通过@Autowired引用XML配置文件中定义的Bean。 123456789101112131415161718import org.springframework.beans.factory.annotation.Autowired;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import org.springframework.context.annotation.Import;@Configuration@ImportResource(&quot;classpath:beans/beans.xml&quot;)//引入xml配置信息public class PeopleConfig { @Bean @Autowired //注入xml里的Bean public People getPeople1(Cat cat, Dog dog){ People people=new People(); people.setC(cat); people.setD(dog); return people; }}","link":"/2019/06/09/Spring-Bean%E7%9A%84%E9%85%8D%E7%BD%AE/"},{"title":"Spring-切面","text":"在使用Spring增强时，增强被织入目标类的所有方法中，假设希望有选择地织入目标类某些特定的方法中，就需要使用切点进行目标连接点的定位了。增强提供了连接点方位信息：如织入方法前面、后面等，而切点进一步描述织入哪些类的哪些方法上。Spring使用org.springframework.aop.Advisor接口表示切面的概念，一个切面同时包含横切代码和连接点信息。 切面可以分为3类：一般切面、切点切面和引介切面 Advisor 代表一般切面，它仅包含一个Advice。Advice本身就是一个简单的切面，只不过它代表的横切的连接点是所有目标类的所有方法，因为横切面太宽泛，所以一般不会直接使用。 PointcutAdvisor 代表具有切点的切面，它包含Advice和Pointcut两个类，这样就能通过类、方法名以及方法方位等信息灵活地定义切面的连接点，提供更具适用性的切面。 IntroductionAdvisor 代表引介切面。引介切面是对应引介增强的特殊切面，它应用于类的层面上，所以引介切点使用ClassFilter进行定义。 静态普通方法名匹配切面Cat类 12345678public class Cat { public void eatIng(String name){ System.out.println(&quot; I'm is Cat I'm eating&quot;); } public void eatEed(String name){ System.out.println(&quot; I'm is Cat I'm finished&quot;); }} Dog类 123456789public class Dog { public void eatIng(String name){ System.out.println(&quot; I'm is Dog I'm eating&quot;); } public void eatEed(String name){ System.out.println(&quot; I'm is Dog I'm finished&quot;); }} 两个类都拥有两个方法名一样的方法，现在再Cat#eatEed方法调用后织入一个增强。用StaticMethodMatcherPointcutAdvisor定义一个切面 123456789101112131415161718import org.springframework.aop.ClassFilter;import org.springframework.aop.support.StaticMethodMatcherPointcutAdvisor;import java.lang.reflect.Method;public class EatAdvisor extends StaticMethodMatcherPointcutAdvisor { public boolean matches(Method method, Class&lt;?&gt; aClass) {// 切点方法匹配规则：方法名为eatEed return &quot;eatEed&quot;.equals(method.getName()); } public ClassFilter getClassFilter(){//切点类匹配规则：为Cat的类或者子类 return new ClassFilter() { public boolean matches(Class&lt;?&gt; aClass) { return Cat.class.isAssignableFrom(aClass); } }; }} 此抽象类唯一需要定义的是matches方法。在默认情况下，该切面匹配所有的类，通过覆盖getClassFilter()方法，让它仅匹配Cat以及其子类。 增强类 123456public class After implements AfterReturningAdvice { public void afterReturning(Object o, Method method, Object[] objects, Object o1) throws Throwable { System.out.println(o1.getClass().getName()+&quot;.&quot;+method.getName()); System.out.println(&quot;瞄！瞄！瞄！ 谢谢老板的饭。&quot;); }} 测试 123456789101112131415161718192021222324252627public class AdvisorTest { static ProxyFactory pf=new ProxyFactory(); static ProxyFactory pf1=new ProxyFactory(); static Cat a=new Cat(); static Dog d=new Dog(); static EatAdvisor e=new EatAdvisor(); static AfterAdvice b=new After(); public static void main(String[] args) { String name=&quot;旺财&quot;; pf.setTarget(a); pf1.setTarget(d); e.setAdvice(b); pf.addAdvisor(e); pf1.addAdvisor(e); Cat c1=(Cat)pf.getProxy(); Dog d1=(Dog)pf1.getProxy(); c1.eatIng(name); System.out.println(); c1.eatEed(name); System.out.println(); d1.eatIng(name); System.out.println(); d1.eatEed(name); }} 结果: 如图可见，切面只织入Cat.eatEed()方法，并没有织入其他的方法。 自动创建代理 在前面都是通过ProxyFactoryBean创建织入切面的代理。Spring提供了自动代理机制。在内部，Spring使用BeanPostProcessor自动完成这项工作。 Spring提供了3个基于BeanPostProcessor的自动代理创建器实现类： BeanNameAutoProxyCreator 基于Bean配置名规则的自动代理创建器。 DefaultAdvisorAutoProxyCreator 基于Advisor匹配机制的自动代理创建器。 AnnotationAwareAspectJAutoProxyCreator 基于Bean中AspectJ注解标签的自动代理创建器。 举一个DefaultAdvisorAutoProxyCreator的例子，给类方法名中带有”Ing”的方法织入一个前置增强。 XML 123456789101112131415&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:p=&quot;http://www.springframework.org/schema/p&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt; &lt;bean id=&quot;c1&quot; class=&quot;org.zmd.model.Cat&quot;/&gt; &lt;bean id=&quot;d1&quot; class=&quot;org.zmd.model.Dog&quot;/&gt; &lt;bean id=&quot;eatAdvice&quot; class=&quot;org.zmd.Advice.Before&quot;/&gt; &lt;bean id=&quot;eatAdvisor&quot; class=&quot;org.springframework.aop.support.RegexpMethodPointcutAdvisor&quot; p:advice-ref=&quot;eatAdvice&quot; p:patterns=&quot;.*Ing.*&quot;/&gt; &lt;!--向Advisor切面注入一个前置增强并匹配方法名带Ing的方法--&gt; &lt;bean class=&quot;org.springframework.aop.framework.autoproxy.DefaultAdvisorAutoProxyCreator&quot;/&gt; &lt;!--自动代理--&gt;&lt;/beans&gt; 测试 12345678910111213public class AdvisorTest1 { public static void main(String[] args) { String path=&quot;Advisor/EndAdvisor.xml&quot;; String name=&quot;旺财&quot;; ApplicationContext con=new ClassPathXmlApplicationContext(path); Cat c=con.getBean(&quot;c1&quot;,Cat.class); Dog d=con.getBean(&quot;d1&quot;,Dog.class); c.eatIng(name); c.eatEed(name); d.eatIng(name); d.eatEed(name); }} 结果: 可见只eatEed()方法并没有被增强，而eatIng()方法被增强了。 基于@AspectJ注解配置切面 @AspectJ使用JDK 5.0注解和正规的AspectJ的切点表达式语言描述切面。直接举个栗子： 配置切面类 @Aspect注解表示这是一个切面，**@Before、@AfterReturning、分别表示前置增强、后置增强。此外还有@Around**(环绕增强)、**@AfterThrowing**(抛出增强)、**@After**(表示Final增强，不管是抛出异常还是正常退出，该增强都会执行，相对于@AfterThrowing和@AfterReturning的混合物)、**@DeclareParents**(引介增强)。value参数代表切点信息，argName表示方法的参数。 12345678910111213141516171819202122232425262728293031import org.aspectj.lang.annotation.*;@Aspectpublic class AspectTest { @Before(value = &quot;execution(* eatIng(..)) &amp;&amp; args(name)&quot; ,argNames = &quot;name&quot;) public void BeforeTest(String name){ System.out.print(&quot;I is BeforeVdvice use execution! I is &quot;+name+&quot;---&quot;); } @AfterReturning(value = &quot;@annotation(org.zmd.Advisor.Aspect.NeedTest) &amp;&amp; args(name)&quot;,argNames = &quot;name&quot;) public void AfterTest(String name){ System.out.println(&quot;I is AfterVdvice use @annotation()! I is &quot;+name+&quot;---&quot;); } @Before(value = &quot;within(org.zmd.model.*) &amp;&amp; args(name)&quot;, argNames = &quot;name&quot;) public void BeforeTest1(String name){ System.out.print(&quot;I is BeforeVdvice use within()! I is &quot;+name+&quot;---&quot;); } @Before(value = &quot;target(org.zmd.model.Cat) &amp;&amp; args(name)&quot;, argNames = &quot;name&quot;) public void AroundTest(String name){ System.out.print(&quot;I is BeforeVdvice use target()! I is &quot;+name+&quot;---&quot;); } @AfterReturning(value = &quot;@within(org.zmd.Advisor.Aspect.NeedTest1) &amp;&amp; args(name)&quot;, argNames = &quot;name&quot;) public void AfterTest1(String name){ System.out.println(&quot;I is AfterVdvice use @within()! I is &quot;+name+&quot;---&quot;); } } execution(方法匹配模式串) 表示满足某一匹配模式的所有目标类方法连接点。如上面匹配目标类中的所有eatIng()方法。 @annotation(方法注解类名) 表示标注了特定注解的目标方法连接点。如上面匹配所有标注了@NeedTest的方法。 12public @interface NeedTest {} within(类名匹配串) 表示特定域下的所有连接点。如上面匹配org.zmd.model包里所有连接点。 target(类名) 匹配类中的所有连接点。如上面匹配Cat类中的所有连接点。 @within(类型注解类名) 匹配类标注特定注解的所有连接点。如上面匹配标了@NeedTest1的类的所有连接点。 还有很多切点函数这里就不一一详述了。 Model类 123456789public class Cat { @NeedTest public void eatIng(String name){ System.out.println(&quot; I'm is Cat I'm eating&quot;); } public void eatEed(String name){ System.out.println(&quot; I'm is Cat I'm finished&quot;); }} 12345678public class Dog { public void eatIng(String name){ System.out.println(&quot; I'm is Dog I'm eating&quot;); } public void eatEed(String name){ System.out.println(&quot; I'm is Dog I'm finished&quot;); }} 12345678910@NeedTest1public class Pig { public void eatIng(String name){ System.out.println(&quot; I'm is Pig I'm eating&quot;); } @NeedTest public void eatEed(String name){ System.out.println(&quot; I'm is Pig I'm finished&quot;); }} 测试 1234567891011121314151617181920212223242526272829303132333435public class AspectTset { static Cat c,c1; static Dog d,d1; static Pig p,p1; static AspectJProxyFactory tf,tf1,tf2; public static void main(String[] args) { init(); c1.eatIng(&quot;小猫&quot;); c1.eatEed(&quot;小猫&quot;); d1.eatIng(&quot;小狗&quot;); d1.eatEed(&quot;小狗&quot;); p1.eatIng(&quot;小猪&quot;); p1.eatEed(&quot;小猪&quot;); } static public void init(){ c=new Cat(); c1=new Cat(); d=new Dog(); d1=new Dog(); p=new Pig(); p1=new Pig(); tf=new AspectJProxyFactory(); tf1=new AspectJProxyFactory(); tf2=new AspectJProxyFactory(); tf.setTarget(c); tf1.setTarget(d); tf2.setTarget(p); tf.addAspect(AspectTest.class); tf1.addAspect(AspectTest.class); tf2.addAspect(AspectTest.class); c1=tf.getProxy(); d1=tf1.getProxy(); p1=tf2.getProxy(); }} 结果: 通过配置使用@AspectJ 通过编程的方式完成织入的工作较为麻烦，一般情况下，都是通过Spring的配置完成切面织入工作。 1234567891011121314&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd&quot;&gt; &lt;aop:aspectj-autoproxy/&gt; &lt;bean id=&quot;c&quot; class=&quot;org.zmd.model.Cat&quot;/&gt; &lt;bean id=&quot;d&quot; class=&quot;org.zmd.model.Dog&quot;/&gt; &lt;bean id=&quot;p&quot; class=&quot;org.zmd.model.Pig&quot;/&gt; &lt;bean class=&quot;org.zmd.Advisor.Aspect.AspectTest&quot;/&gt;&lt;/beans&gt; 测试 123456789101112131415public class AspectTest1 { public static void main(String[] args) { String path=&quot;Advisor/AspectTest.xml&quot;; ApplicationContext con=new ClassPathXmlApplicationContext(path); Cat c=con.getBean(&quot;c&quot;,Cat.class); Dog d=con.getBean(&quot;d&quot;,Dog.class); Pig p=con.getBean(&quot;p&quot;,Pig.class); c.eatIng(&quot;小猫&quot;); c.eatEed(&quot;小猫&quot;); d.eatIng(&quot;小狗&quot;); d.eatEed(&quot;小狗&quot;); p.eatIng(&quot;小猪&quot;); p.eatEed(&quot;小猪&quot;); }} 效果和上面一样。可以看出通过配置完成切面织入工作会显得简便多了。 基于Schema配置切面XML 配置里通过&lt;aop:pointcut &gt;定义了4个切点。通过&lt;&lt;aop:aspect &gt;定义切面，切面里可以包含多个增强，&lt;aop:config &gt;里可以定义多个切面。proxy-target-class属性为true时，切面均使用CGLib动态代理技术。如果在&lt;aop:config &gt;下直接定义&lt;aop:pointcut &gt;，必须保证在&lt;aop:aspect &gt;之前定义。 1234567891011121314151617181920212223242526272829303132333435&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd&quot;&gt; &lt;aop:config proxy-target-class=&quot;true&quot;&gt; &lt;!--切点声明--&gt; &lt;!--Cat类eatIng方法切点--&gt; &lt;aop:pointcut id=&quot;catEatIng&quot; expression=&quot;target(org.zmd.model.Cat) and execution(* eatIng(..)) and args(name)&quot;/&gt; &lt;!--Dog类Bad方法切点--&gt; &lt;aop:pointcut id=&quot;dogBad&quot; expression=&quot;target(org.zmd.model.Dog) and execution(* Bad(..)) and args(name)&quot;/&gt; &lt;!--Cat类getName方法切点--&gt; &lt;aop:pointcut id=&quot;getName&quot; expression=&quot;target(org.zmd.model.Cat) and execution(* getName(..))&quot;/&gt; &lt;!--切面声明--&gt; &lt;aop:aspect ref=&quot;adviceMothods&quot;&gt; &lt;!--使用增强类里的eatIng方法--&gt; &lt;aop:before method=&quot;eatIng&quot; pointcut-ref=&quot;catEatIng&quot;/&gt; &lt;!--使用增强类里的getName方法--&gt; &lt;aop:after-returning method=&quot;getName&quot; pointcut-ref=&quot;getName&quot; returning=&quot;name&quot;/&gt; &lt;!--使用增强类里的beforeAdvice方法--&gt; &lt;aop:before method=&quot;beforeAdvice&quot; pointcut-ref=&quot;getName&quot;/&gt; &lt;!--使用增强类里的Bad方法--&gt; &lt;aop:after-throwing method=&quot;Bad&quot; pointcut-ref=&quot;dogBad&quot;/&gt; &lt;/aop:aspect&gt; &lt;/aop:config&gt; &lt;!--增强方法所在类的Bean--&gt; &lt;bean id=&quot;adviceMothods&quot; class=&quot;org.zmd.Advisor.Schema.AdviceMethods&quot;/&gt; &lt;bean class=&quot;org.zmd.model.Cat&quot;/&gt; &lt;bean class=&quot;org.zmd.model.Dog&quot;/&gt;&lt;/beans&gt; 增强方法类 里面包含了增强的方法。 123456789101112131415public class AdviceMethods { public void eatIng(String name){ System.out.println(&quot;I is &quot;+name+&quot; from Schema!&quot;); } public void getName(String name){ System.out.println(&quot;I is &quot;+name+&quot; from after-returning!&quot;); } public void beforeAdvice(){ System.out.println(&quot;I is beforeAdvice!&quot;); } public void Bad(String name){ System.out.println(&quot;I is &quot;+name+&quot; from after-throwing!&quot;); }} 测试 1234567891011121314public class SchemaTest { public static void main(String[] args) { String path=&quot;Advisor/SchemaTest.xml&quot;; ApplicationContext con=new ClassPathXmlApplicationContext(path); Cat c=con.getBean(Cat.class); Dog d=con.getBean(Dog.class); c.setName(&quot;小猫&quot;); c.getName(); System.out.println(&quot;----------------&quot;); c.eatIng(&quot;旺财&quot;); System.out.println(&quot;----------------&quot;); d.Bad(&quot;广生&quot;); }} 结果","link":"/2019/06/17/Spring-%E5%88%87%E9%9D%A2/"},{"title":"Spring-增强","text":"AOP增强是指在目标类的连接点上织入一段代码。连接点由两个信息确定，一、方法表示的程序执行点；二、用相对点表示的方位。简单的来说，增强就是在目标类的方法执行前或者方法执行后拦截并加一段代码。一个类被AOP增强后，就产生了一个结果类，它是融合了原类和增强逻辑的代理类。 Spring支持5种类型的增强，按照增强在目标类方法的连接点位置，可以分为以下5类： BeforeAdvice(前置增强) BeforeAdvice类代表前置增强，因为Spring只支持方法级增强，所以MethodBeforeAdvice是目前可用的前置增强，表示在目标方法执行前实施增强。简单来说，就是在目标方法执行前拦截并执行一些代码。 AfterReturningAdvice(后置增强) AfterReturningAdvice代表后置增强，表示在目标方法执行后实施增强。简单来说，就是在目标方法执行后执行一些代码。 MethodInterceptor(环绕增强) MethodInterceptor代表环绕增强，表示在目标方法执行前后实施增强。简单来说，就是在目标方法执行前和后都会拦截并执行一些代码。 ThrowsAdvice(异常抛出增强) ThrowsAdvice代表抛出异常增强，表示在目标方法抛出异常后实施增强。简单来说，就是在目标方法抛出异常的时候拦截并执行一些代码。 IntroductionInterceptor(引介增强) IntroductionInterceptor代表引介增强，表示在目标类中添加一些新的方法和属性。 1.前置增强 前置增强是在目标方法调用前执行，下面定义一个Cat类，里面有两个方法，分别为eatIng和eatEed。一只不可爱的猫的情况： 12345678public class Cat { public void eatIng(String name){ System.out.println(&quot; I'm eating&quot;); } public void eatEed(String name){ System.out.println(&quot; I'm finished&quot;); }} 闷不做声，毫无感情。下面通过增强来让这只猫显得可爱一些。 增强类 MethodBeforeAdvice接口仅定义了唯一方法。method为目标类的方法；objects为目标类方法的入参；o为目标类实例。 12345678import org.springframework.aop.MethodBeforeAdvice;import java.lang.reflect.Method;public class Before implements MethodBeforeAdvice {//在目标类方法调用前执行 public void before(Method method, Object[] objects, Object o) throws Throwable { String name=(String)objects[0];//获取方法第一个入参 System.out.print(&quot;瞄！瞄！瞄！ I is &quot;+name); }} 测试 12345678910111213public class BeforeTest { public static void main(String[] args) { Cat c=new Cat(); BeforeAdvice advice=new Before(); ProxyFactory pf=new ProxyFactory();// Spring提供的代理工厂 pf.setTarget(c);//设置代理的目标 pf.addAdvice(advice);//为代理目标添加增强 Cat c1=(Cat)pf.getProxy(); System.out.println(&quot;我是Before增强&quot;); c1.eatIng(&quot;旺财&quot;); c1.eatEed(&quot;旺财&quot;); }} 下面通过xml配置声明一个代理： 12345678910111213141516&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:p=&quot;http://www.springframework.org/schema/p&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt; &lt;!-- 需要代理的对象--&gt; &lt;bean id=&quot;target&quot; class=&quot;org.zmd.model.Cat&quot;/&gt; &lt;!--指定使用的增强--&gt; &lt;bean id=&quot;before&quot; class=&quot;org.zmd.Advice.Before&quot;/&gt; &lt;!--如果代理的对象实现了接口，需要用p:proxyInterfaces=&quot;&quot;指定实现的接口--&gt; &lt;bean id=&quot;c&quot; class=&quot;org.springframework.aop.framework.ProxyFactoryBean&quot; p:interceptorNames=&quot;before&quot; p:target-ref=&quot;target&quot;/&gt;&lt;/beans&gt; 测试 12345678910public class BeforeTest1 { public static void main(String[] args) { String path=&quot;Advice/Before.xml&quot;; ApplicationContext con=new ClassPathXmlApplicationContext(path); Cat c= con.getBean(&quot;c&quot;,Cat.class); System.out.println(&quot;我是Before增强&quot;); c.eatIng(&quot;旺财&quot;); c.eatEed(&quot;旺财&quot;); }} 上面两个测试的结果： 2.后置增强 后置增强是在目标类方法调用后执行。下面通过后置增强让猫显得更加可爱。 增强类 通过实现AfterReturningAdvice接口来定义增强的逻辑。o为目标实例方法返回的结果；method为目标类方法；objects为目标实例的方法的入参；o1为目标类实例。 1234567import org.springframework.aop.AfterReturningAdvice;import java.lang.reflect.Method;public class After implements AfterReturningAdvice { public void afterReturning(Object o, Method method, Object[] objects, Object o1) throws Throwable { System.out.println(&quot;瞄！瞄！瞄！ 谢谢老板的饭。&quot;); }} 测试类 123456789101112131415public class AfterTest { public static void main(String[] args) { Cat c=new Cat(); BeforeAdvice before=new Before(); AfterReturningAdvice aftet=new After(); ProxyFactory pf =new ProxyFactory(); pf.setTarget(c);//设置代理的对象 pf.addAdvice(before);//添加前置增强 pf.addAdvice(aftet);//添加后置增强 Cat c1=(Cat) pf.getProxy(); System.out.println(&quot;我是After增强&quot;); c1.eatIng(&quot;旺财&quot;); c1.eatEed(&quot;旺财&quot;); }} XML配置 123456789101112&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:p=&quot;http://www.springframework.org/schema/p&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt; &lt;bean id=&quot;target&quot; class=&quot;org.zmd.model.Cat&quot;/&gt; &lt;bean id=&quot;after&quot; class=&quot;org.zmd.Advice.After&quot;/&gt; &lt;bean id=&quot;before&quot; class=&quot;org.zmd.Advice.Before&quot;/&gt; &lt;bean id=&quot;c&quot; class=&quot;org.springframework.aop.framework.ProxyFactoryBean&quot; p:target-ref=&quot;target&quot; p:interceptorNames=&quot;after,before&quot;/&gt;&lt;/beans&gt; 测试结果: 3.环绕增强 环绕增强的作用已经很明显了，环绕增强允许在目标类方法调用前后织入横切逻辑，它综合实现了前置、后置增强两者的功能。 增强类 12345678910111213import org.aopalliance.intercept.MethodInterceptor;import org.aopalliance.intercept.MethodInvocation;public class Interceptor implements MethodInterceptor { public Object invoke(MethodInvocation methodInvocation) throws Throwable { Object [] o=methodInvocation.getArguments(); String name=(String)o[0]; System.out.print(&quot;瞄！瞄！瞄！ I is &quot;+name);//目标方法执行前调用 Object ob=methodInvocation.proceed();//通过反射机制调用目标方法 System.out.println(&quot;瞄！瞄！瞄！ 谢谢老板的饭。&quot;);//目标方法执行后调用 return ob; }} XML配置 1234567891011&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:p=&quot;http://www.springframework.org/schema/p&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt; &lt;bean id=&quot;target&quot; class=&quot;org.zmd.model.Cat&quot;/&gt; &lt;bean id=&quot;in&quot; class=&quot;org.zmd.Advice.Interceptor&quot;/&gt; &lt;bean id=&quot;c&quot; class=&quot;org.springframework.aop.framework.ProxyFactoryBean&quot; p:interceptorNames=&quot;in&quot; p:target-ref=&quot;target&quot;/&gt;&lt;/beans&gt; 测试: 4.异常抛出增强 定义Dog类，里面有两个抛出异常的方法。 1234567891011import java.sql.SQLException;public class Dog { public void Hungry(String name) throws Exception{ throw new SQLException(&quot;我饿得都不认识你了！铲屎官&quot;); } public void Bad(String name){ throw new RuntimeException(&quot;我生病了！铲屎官！&quot;); }} 增强类 12345678910import org.springframework.aop.ThrowsAdvice;import java.lang.reflect.Method;public class Throw implements ThrowsAdvice { public void afterThrowing(Method method,Object [] args,Object target,Exception ex) throws Throwable{ System.out.println(&quot;**************&quot;); System.out.println(&quot;函数名:&quot;+method.getName()); System.out.println(&quot;抛出异常: 我是&quot;+args[0]+&quot; &quot;+ex.getMessage()); System.out.println(&quot;成功增强异常&quot;); }} 测试类 12345678910111213141516public class ThrowTest { public static void main(String[] args) { Dog d=new Dog(); ProxyFactory pf=new ProxyFactory(); ThrowsAdvice t=new Throw(); pf.setTarget(d); pf.addAdvice(t); Dog d1=(Dog) pf.getProxy(); try { d1.Hungry(&quot;广生&quot;); } catch (Exception e) { e.printStackTrace(); } d1.Bad(&quot;广生&quot;); }} 结果：","link":"/2019/06/12/Spring-%E5%A2%9E%E5%BC%BA/"},{"title":"Spring-注入","text":"1.属性注入 属性注入即通过setXxxx()方法注入Bean的属性值或依赖对象，由于属性注入方式具有可选择性和灵活性高的优点，因此属性注入是实际应用中最常采用的注入方式。 属性注入要求Bean提供一个默认的构造函数，并为需要注入的属性提供对应的Setter方法。Spring先调用Bean的默认构造函数实例化对象，然后通过反射的方式调用Setter方法注入属性值。 12345678910111213141516171819202122232425262728public class Cat { private String color; private int age; private int weigth; private People people; public Cat(){ } public void setColor(String color) { this.color = color; } public void setAge(int age) { System.out.println(&quot;有setAge方法但是没有设置属性！&quot;); } public void setWeigth(int weigth) { this.weigth = weigth; } public int getWeigth() { return weigth; } public String getColor() { return color; }} Cat类中定义了3个属性，并分别提供了对应的Setter方法和默认构造函数。 配置文件中对cat进行属性注入 12345678910111213&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:p=&quot;http://www.springframework.org/schema/p&quot; //p命名空间，简化配置 xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt; &lt;bean id=&quot;c&quot; class=&quot;com.smart.model.Cat&quot; p:weigth=&quot;50&quot; p:age=&quot;4&quot; p:color=&quot;白色&quot; p:people-ref=&quot;p&quot; /&gt; &lt;bean id=&quot;p&quot; class=&quot;com.smart.model.People&quot;/&gt;&lt;/beans&gt; 测试 12345678public class test { public static void main(String[] args) { ApplicationContext ctx=new ClassPathXmlApplicationContext(&quot;beans/cat.xml&quot;); Cat c=ctx.getBean(&quot;c&quot;, Cat.class); System.out.println(&quot;使用ClassPathXmlApplicationContext启动Spring容器&quot;); System.out.println(c.getAge()+&quot; &quot;+c.getColor()+&quot; &quot;+c.getWeigth()); }} 输出： PS：Spring只会检查Bean中是否有对应的Setter方法，至于Bean中是否有对应的属性变量则不做要求。如上面。 2.构造函数注入 构造函数注入是除属性注入之外的另一种常用的注入方式，它保证一些必要的属性在Bean实例化时就得到设置，并且确保了Bean实例在实例化后就可以使用。 按类型匹配入参 如此构造函数： 1234public Cat(String name,double price){ this.name=name; this.price=price;} 配置： 1234&lt;bean id=&quot;c3&quot; class=&quot;com.smart.model.Cat&quot;&gt; &lt;constructor-arg type=&quot;java.lang.String&quot; value=&quot;旺财&quot;/&gt; &lt;constructor-arg type=&quot;double&quot; value=&quot;20&quot;/&gt;&lt;/bean&gt; 按索引匹配入参 如此构造函数：第二个和第三个都是int类型 12345public Cat(String color, int age, int weigth) { this.color = color; this.age = age; this.weigth = weigth;} 配置： 12345&lt;bean id=&quot;c4&quot; class=&quot;com.smart.model.Cat&quot;&gt; &lt;constructor-arg index=&quot;0&quot; value=&quot;紫色&quot;/&gt; &lt;constructor-arg index=&quot;1&quot; value=&quot;4&quot;/&gt; &lt;constructor-arg index=&quot;2&quot; value=&quot;30&quot;/&gt;&lt;/bean&gt; 联合使用类型和索引匹配入参 如下面两个构造函数：需要联合使用type和index才能确定配置项和构造函数入参的对应关系。 12345678910public Cat(String color, int age, int weigth) { this.color = color; this.age = age; this.weigth = weigth;}public Cat(String color, int age, double price) { this.color = color; this.age = age; this.price = price;} 配置：配置第二个构造函数 12345&lt;bean id=&quot;c5&quot; class=&quot;com.smart.model.Cat&quot;&gt; &lt;constructor-arg index=&quot;0&quot; type=&quot;java.lang.String&quot; value=&quot;蓝色&quot;/&gt; &lt;constructor-arg index=&quot;1&quot; type=&quot;int&quot; value=&quot;3&quot;/&gt; &lt;constructor-arg index=&quot;2&quot; type=&quot;double&quot; value=&quot;600&quot;/&gt;&lt;/bean&gt; 通过自身类型反射匹配入参 如果Bean构造函数入参的类型是可辨别的(其他的Bean)，由于Java反射机制可以获取构造函数入参的类型，即使构造函数注入的配置不提供类型和索引的信息，Spring依旧可以正确地完成构造函数的注入工作。 如下面People类的构造函数： 123456public People(String name, int age, Cat c, Dog d) { this.name = name; this.age = age; this.c = c; this.d = d;} 配置： 12345678910111213141516&lt;bean id=&quot;p&quot; class=&quot;com.smart.model.People&quot;&gt; &lt;constructor-arg value=&quot;老GS&quot;/&gt; &lt;constructor-arg value=&quot;21&quot;/&gt; &lt;constructor-arg ref=&quot;d4&quot;/&gt;//引用其他Bean &lt;constructor-arg ref=&quot;c4&quot;/&gt;//引用其他Bean&lt;/bean&gt;&lt;bean id=&quot;c4&quot; class=&quot;com.smart.model.Cat&quot; p:weigth=&quot;40&quot; p:color=&quot;橘色&quot; p:age=&quot;2&quot;/&gt;&lt;bean id=&quot;d4&quot; class=&quot;com.smart.model.Dog&quot; p:weigth=&quot;30&quot; p:color=&quot;白色&quot; p:age=&quot;3&quot;/&gt; 执行： 12People p1=cxt.getBean(&quot;p&quot;, People.class); System.out.println(p1.getName()+&quot; &quot;+p1.getC().getColor()+&quot; &quot;+p1.getD().getColor()); **输出: ** 老GS 橘色 白色 注入集合类型属性 List 为People添加一个List类型的hobby属性并添加setter。 1234private List favorites=new ArrayList();public void setFavorites(List favorites) { this.favorites = favorites;} Xml: 12345678910&lt;bean id=&quot;p2&quot; class=&quot;com.smart.model.People&quot;&gt; &lt;property name=&quot;favorites&quot;&gt; &lt;list&gt; &lt;value&gt;rap&lt;/value&gt; &lt;value&gt;唱&lt;/value&gt; &lt;value&gt;跳&lt;/value&gt; &lt;value&gt;打篮球&lt;/value&gt; &lt;/list&gt; &lt;/property&gt; &lt;/bean&gt; 执行: 12People p2=cxt.getBean(&quot;p2&quot;, People.class); System.out.println(p2.getFavorites()); 输出：rap, 唱, 跳, 打篮球 List属性既可以通过&lt; value &gt;出入字符串，也可以通过&lt; ref &gt;注入容器中的其他Bean。 Map 为People添加一个Map类型的work属性并添加setter: 12345private Map work=new HashMap();public void setWork(Map work) { this.work = work;} Xml 12345678&lt;bean id=&quot;p3&quot; class=&quot;com.smart.model.People&quot;&gt; &lt;property name=&quot;work&quot;&gt; &lt;map&gt; &lt;entry key=&quot;9点&quot; value=&quot;上课&quot;/&gt; &lt;entry key=&quot;18点&quot; value=&quot;放学&quot;/&gt; &lt;/map&gt; &lt;/property&gt;&lt;/bean&gt; 执行 12People p2=cxt.getBean(&quot;p3&quot;, People.class); System.out.println(p2.getWork()); 输出：9点=上课, 18点=放学 假如某一Map元素的键和值都是对象，则采取以下配置： 1234&lt;entry&gt; &lt;key&gt;&lt;ref bean=&quot;keyBean&quot;&gt;&lt;/ref&gt;&lt;/key&gt; &lt;ref bean=&quot;valueBean&quot;&gt;&lt;/ref&gt;&lt;/entry&gt; 通过util命名空间配置集合类型的Bean 如果希望配置一个集合类型的Bean，而非一个集合类型的属性，则可以通过util命名空间进行配置。 Xml 1234567891011121314151617181920212223242526&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:util=&quot;http://www.springframework.org/schema/util&quot;//引入util命名空间 xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/util //util:list声明 http://www.springframework.org/schema/util/spring-util.xsd //util:list声明 &quot;&gt; &lt;util:list id=&quot;list1&quot; list-class=&quot;java.util.LinkedList&quot;&gt; &lt;value&gt;看电视&lt;/value&gt; &lt;value&gt;玩游戏&lt;/value&gt; &lt;value&gt;运动&lt;/value&gt; &lt;/util:list&gt; &lt;util:set id=&quot;set1&quot;&gt; &lt;value&gt;看电视&lt;/value&gt; &lt;value&gt;玩游戏&lt;/value&gt; &lt;value&gt;运动&lt;/value&gt; &lt;/util:set&gt; &lt;util:map id=&quot;map1&quot;&gt; &lt;entry key=&quot;9点&quot; value=&quot;吃饭&quot;/&gt; &lt;entry key=&quot;18点&quot; value=&quot;吃晚饭&quot;/&gt; &lt;/util:map&gt;&lt;/beans&gt; 测试 12345678910111213141516import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;import java.util.List;import java.util.Map;import java.util.Set;public class test3 { public static void main(String[] args) { ApplicationContext cxt=new ClassPathXmlApplicationContext(&quot;beans/util.xml&quot;); List list=cxt.getBean(&quot;list1&quot;,java.util.LinkedList.class); Set set=cxt.getBean(&quot;set1&quot;,java.util.Set.class); Map map=cxt.getBean(&quot;map1&quot;,java.util.Map.class); System.out.println(list+&quot; &quot;+set+&quot; &quot;+map); }} 输出： [看电视, 玩游戏, 运动] [看电视, 玩游戏, 运动] {9点=吃饭, 18点=吃晚饭} 自动装配 &lt; bean &gt;元素提供了一个指定自动装配类型的属性：**autowire=”&lt;自动装配类型&gt;”**。Spring提供了4种自动装配类型。 byName 根据名称进行自动匹配。假设People有一个名为cat的属性，如果容器中刚好有一个名为car的Bean，Spring就会自动将其装配给People的cat属性。 byType 根据类型进行自动匹配。假设People有一个名为cat的属性，如果容器中刚好有一个Cat类型的Bean，Spring就会自动将其装配给People的cat属性。 constructor 与byType类似，只不过它是针对构造函数注入而言的，假设People有一个构造函数，构造函数包含一个Cat类型的入参，如果容器中有一个Cat类型的Bean，则Spring将自动把这个Bean作为People构造函数的入参，如果容器中没有找到和构造函数入参匹配类型的Bean，Spring抛出异常。 autodetect 根据Bean的自省机制决定采用byType还是constructor进行自动装配：如果Bean提供了默认的构造函数，则采用byType；否则采用constructor。 如将上面id=”p”的Bean改为： 123&lt;bean id=&quot;p&quot; class=&quot;com.smart.model.People&quot; p:name=&quot;老GS&quot; autowire=&quot;byType&quot;/&gt; 执行： 12People p1=cxt.getBean(&quot;p&quot;, People.class); System.out.println(p1.getName()+&quot; &quot;+p1.getC().getColor()+&quot; &quot;+p1.getD().getColor()); **输出： **老GS 橘色 白色 可见，容器自动将c4、d4注入了。","link":"/2019/06/08/Spring-%E6%B3%A8%E5%85%A5/"},{"title":"Spring简介","text":"1.简介 Spring框架是由于软件开发的复杂性而创建的。Spring使用的是基本的JavaBean来完成以前只可能由EJB完成的事情。然而，Spring的用途不仅仅限于服务器端的开发。从简单性、可测试性和松耦合性角度而言，绝大部分Java应用都可以从Spring中受益。 ps:EJB是sun的JavaEE服务器端组件模型，设计目标与核心应用是部署分布式应用程序。简单来说就是把已经编写好的程序(类)打包放在服务器上执行。凭借Java跨平台的优势，用EJB技术部署的分布式系统可以不限于特定的平台。 Spring是一个轻量级的控制反转(Ioc)和面向切面(AOP)的容器框架。 轻量 从大小与开销两方面而言Spring都是轻量的。完整的Spring框架可以在一个大小只有1MB多的JAR文件里发布。并且Spring所需的处理开销也是微不足道的。此外，Spring是非侵入式的，Spring应用中的对象不依赖于Spring的特定类。 控制反转 Spring通过一种称作控制反转(IOC)的技术促进了松耦合。当应用了IOC，一个对象依赖的其他对象会通过被动的方式传递进来，而不是这个对象自己创建或者查找依赖对象。IOC和JNDI(一种标准的Java命名系统接口)相反，IOC不是对象从容器中查找依赖，而是容器在对象初始化时不等对象请求就主动将依赖传递给它。 面向切面 Spring提供了面向切面编程的丰富支持，允许通过分离应用的业务逻辑与系统服务和事务进行内聚性的开发。应用对象只实现它们应该做的(完成业务逻辑)仅此而已。它们并不负责其他系统级关注点。 容器 Spring包含并管理应用对象的配置和生命周期，在这个意义上它是一种容器，你可以配置你的每个bean如何被创建，你的bean可以创建一个单独的实例或者每次需要时都生成一个新的实例。然而，Spring不应该被混同于传统的重量级的EJB容器，它们经常是庞大与笨重的，难以使用。 框架 Spring可以将简单的组件配置、组合成为复杂的应用。在Spring中，应用对象被声明式地组合，典型地是在一个XML文件里。Spring也提供了很多基础功能(事务管理、持久化框架集成、等)将应用逻辑的开发留给了你。 所有Spring的这些特征使你能够编写更干净、更可管理、并且更易于测试的代码。它们也成为Spring中的各种模块提供了基础支持。 2.特点 方便解耦，简化开发 通过Spring提供的IoC容器，可以将对象之间的依赖关系交由Spring进行控制，避免硬编码所造成的过度程序耦合。有了Spring，用户就不必再为单实例模式类、属性文件解析等这些很底层的需求编写代码，而可以更加专注于上层的应用。 AOP编程的支持 在Spring提供的AOP功能，用户可以方便地进行面向切面编程，许多不容易用传统面向对象编程(OOP)实现的功能都可以通过AOP轻松应对。 声明事务的支持 在Spring中，用户可以从单调烦闷的事务管理代码中解脱出来，通过声明式事务灵活地进行事务管理，提高开发效率和质量。 方便程序的测试 可以用非容器依赖的编程方式进行几乎所有的测试工作，在Spring中，测试不再是昂贵的操作，而是随手可做的事情。 方便集成各种优秀的框架 Spring不排斥各种优秀的开源框架，相反，Spring可以降低各种框架的使用难度，Spring提供了对各种优秀框架(如 Struts、Hibernate、Hessian、Quartz等)的直接支持。 降低Java EE API的使用难度 Spring为很多难用的Java EE API(如JDBC、JavaMail、远程调用等)提供了一个薄薄的封装层，通过Spring的简易封装，大大降低了这些Java EE API的使用难度。 Java源码是经典的学习范例 Spring的源码设计精妙、结构清晰、匠心独用，处处体现着大师对Java设计模式的灵活运用以及对Java技术的高深造诣。Spring框架源码无疑是Java技术的最佳实践范例。如果想在短时间内迅速提高自己的Java技术水平和应用开发水平，那么学习和研究Spring源码就可以让你获得意想不到的效果。 Spring框架结构 IoC 控制反转(IoC)是Spring容器的内核，AOP、声明事务等功能都是在此基础上开花结果的。所谓IoC，就是通过容器来控制业务对象之间的依赖关系，而非传统实现中，由代码直接操控。这也就是控制反转概念所在：控制权由应用代码中转到了外部容器，控制权的转移，就是反转。控制权转移带来的好处就是降低了业务对象之间的依赖程度。 Spring核心模块实现了IoC的功能，它将类和类之间的依赖从代码中脱离出来，用配置的方式进行依赖关系描述，有IoC容器负责依赖类之间的创建、拼接、管理、获取等工作。BeanFactory接口是Spring框架的核心接口，它实现了容器的许多核心功能。 Context模块构建于核心模块之上，扩展了BeanFactory的功能，添加了i18n国际化、Bean生命周期控制、框架事件体系、资源加载透明化等多项功能。此外，该模块还提供了许多企业级服务的支持，如邮箱服务、任务调度、JNDI定位、EJB集成、远程访问等。ApplicationContext是Context模块的核心接口。 AOP AOP是继OOP之后，对编程设计思想影响最大的技术之一。AOP是进行横切逻辑编程的思想，它开括了人们考虑问题的思路。在AOP模块里，Spring提供了满足AOP Alliance规范的实现，此外，还整合了AspectJ这种AOP语言级的框架。在Spring里实现AOP编程有许多的选择。Java 5.0 引入java.lang.instrument,允许在JVM启动时启用一个代理类，通过该代理类在运行期修改类的字节码，改变一个类的功能，实现AOP的功能。","link":"/2019/05/29/Spring%E7%AE%80%E4%BB%8B/"},{"title":"在Spring里使用Hibernate","text":"在Hibernate配置文件中一般会定义3个方面的信息：数据源、对象关联映射文件以及Hibernate控制属性信息。在Hibernate中，可以使用一个配置文件创建一个SessionFactory实例，在Spring中，可以利用 LocalSessionFactoryBean指定一个Hibernate来达到同样的目的。 12&lt;bean id=&quot;sessionFactory&quot; class=&quot;org.springframework.orm.hibernate5.LocalSessionFactoryBean&quot;P:configLocation=&quot;classpath:hibernate.cfg,xml&quot;/&gt; 如有多个配置文件，可用逗号隔开。LocalSessionFactoryBean将利用Hibernate配置文件创建一个 SessionFactory代理对象，以便和Spring的事务管理机制配合工作,当数据访问代码使用SessionFactory时，可以获得线程绑定的Session，不管工作于本地还是全局事务，都能正确参与到当前的Spring事务管理中。 Spring风格的配置 Spring可以对ORM技术提供统一的数据管理机制，可以在Spring容器中定义数据源、指定映射文件、设置Hibernate控制属性等信息，完成集成组装的工作，完全抛开了hibernate.cfg.xml配置文件。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xmlns:p=&quot;http://www.springframework.org/schema/p&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd&quot;&gt; &lt;!--JDBC配置信息--&gt; &lt;context:property-placeholder location=&quot;classpath:jdbc.properties&quot;/&gt; &lt;!--配置数据源--&gt; &lt;bean id=&quot;dataSoruce&quot; class=&quot;org.apache.commons.dbcp2.BasicDataSource&quot; destroy-method=&quot;close&quot; p:driverClassName=&quot;${jdbc.driverClassName}&quot; p:url=&quot;${jdbc.url}&quot; p:username=&quot;${jdbc.username}&quot; p:password=&quot;${jdbc.password}&quot;/&gt; &lt;bean id=&quot;sessionFactory&quot; class=&quot;org.springframework.orm.hibernate5.LocalSessionFactoryBean&quot; p:dataSource-ref=&quot;dataSoruce&quot;&gt; &lt;!--指定Hibernate实体类映射文件--&gt; &lt;property name=&quot;mappingLocations&quot;&gt; &lt;list&gt; &lt;value&gt;classpath*:/model/User.hbm.xml&lt;/value&gt; &lt;/list&gt; &lt;/property&gt; &lt;!--指定Hibernate配置属性--&gt; &lt;property name=&quot;hibernateProperties&quot;&gt; &lt;props&gt; &lt;prop key=&quot;hibernate.dialect&quot;&gt; org.hibernate.dialect.MySQLDialect &lt;/prop&gt; &lt;prop key=&quot;hibernate.show_sql&quot;&gt; true &lt;/prop&gt; &lt;prop key=&quot;hibernate.format_sql&quot;&gt; true &lt;/prop&gt; &lt;/props&gt; &lt;/property&gt; &lt;/bean&gt; &lt;bean id=&quot;hibernateTemplate&quot; class=&quot;org.springframework.orm.hibernate5.HibernateTemplate&quot; p:sessionFactory-ref=&quot;sessionFactory&quot;/&gt; &lt;bean class=&quot;model.User&quot;/&gt;&lt;/beans&gt; 由于mappingLocations属性的类型是Resource[]，因此也支持以下简洁的配置方式： 12p:dataSource-ref=&quot;dataSoruce&quot;p:mappingLocations=&quot;classpath:/model/*hbm.xml&quot; 测试 123456789101112131415161718192021222324252627public class HibernateTest1 { static final String path=&quot;SpringXml/HibernateXml.xml&quot;; static ApplicationContext con= new ClassPathXmlApplicationContext(path); static HibernateTemplate hibernateTeplate; static SessionFactory sessionFactory; static Session session; public void init(){ hibernateTeplate=con.getBean(&quot;hibernateTemplate&quot;,HibernateTemplate.class); sessionFactory=hibernateTeplate.getSessionFactory(); session=sessionFactory.openSession(); session.beginTransaction();//开启事务 } public void close(){ session.close(); sessionFactory.close(); } @Test public void findAllUser(){//查询表里所有的信息 init(); Query query=session.createQuery(&quot;from User &quot;); List&lt;User&gt; list=query.list(); for (User u:list) System.out.println(u.getName()+&quot; &quot;+u.getPassword()+&quot; &quot;+u.getPhone()); close(); }} 结果： 使用注解配置 Hibernate不但可以使用XML提供的ORM配置信息，也可以直接在领域对象类中通过注解定义ORM映射信息。Hibernate不但自己定义了一套注解，还支持JSR 220的JPA注解。 12345678910111213141516171819202122@Entity//声明实体类@Table(name = &quot;h_user&quot;)//映射的表为h_userpublic class HibernateConfig implements Serializable { @Id//主键 @GeneratedValue(strategy = GenerationType.IDENTITY)//自增 @Column(name = &quot;id&quot;)//对应表中的列 protected int id; @Column(name = &quot;name&quot;) protected String name; @Column(name = &quot;password&quot;) protected String password; @Column(name = &quot;phone&quot;) protected String phone; @Column(name = &quot;address&quot;) protected String adress; //省略get、set函数} Hibernate通过addAnnotatedClass()或addPackage()方法加载使用JPA注解的实体类，获取映射的元数据信息，并在此基础上创建SessionFactory实例。 12345Configuration configuration=new Configuration().configure();configuration.addAnnotatedClass(HibernateConfig.class);SessionFactory sessionFactory=configuration.buildSessionFactory();Session session=sessionFactory.openSession();session.beginTransaction(); Spring配置: 12345678910111213141516171819&lt;bean id=&quot;sessionFactory&quot; class=&quot;org.springframework.orm.hibernate5.LocalSessionFactoryBean&quot; p:dataSource-ref=&quot;dataSoruce&quot;&gt; &lt;!--扫描并加载这些包路径(包括子包)的所有带注解实体类，扫描多个包可用逗号隔开--&gt; &lt;property name=&quot;packagesToScan&quot; value=&quot;Config&quot;/&gt; &lt;property name=&quot;hibernateProperties&quot;&gt; &lt;props&gt; &lt;prop key=&quot;hibernate.dialect&quot;&gt; org.hibernate.dialect.MySQLDialect &lt;/prop&gt; &lt;prop key=&quot;hibernate.show_sql&quot;&gt; true &lt;/prop&gt; &lt;prop key=&quot;hibernate.format_sql&quot;&gt; true &lt;/prop&gt; &lt;/props&gt; &lt;/property&gt;&lt;/bean&gt;","link":"/2019/06/23/%E5%9C%A8Spring%E9%87%8C%E4%BD%BF%E7%94%A8Hibernate/"},{"title":"Servlet技术","text":"Servlet是用Java编写的运行在Web服务器中的程序，因此它可以调用服务器端的类，也可以被调用，它本身也就是一个类。 PS：要注意区分Servlet、JavaScript以及Java Applet。JavaScript是运行在客户端浏览器中的脚本程序；Java Applet是运行在客户端的Java小程序；而Servlet是运行在服务器端的程序。 JSP页面编写完毕后，在Web引擎中运行前也会被编译器先转换为Servlet，在编译成字节码文件，因此JSP页面与Servlet是一一对应的。 Servlet的工作原理 Servlet由Web服务器引擎复杂编译执行，当客户端浏览器访问Servlet时，服务器将启动一个线程来响应，而并非CGI技术的进程。因此相对CGI方式占用的系统资源(特别是内存)比较少，具有较高的运行效率。 当Web服务器中的Servlet被请求访问时，此Servlet被加载到Java虚拟机中，在Servlet中要接受HTTP请求并作出相应处理。由于Servlet是在服务器运行的，对客户完全透明，因此比Java Applet具有更好的安全性，当服务器有防火墙的保护时，Servlet也受到防火墙的保护。 Servlet相关的类和方法 要开发Servlet重点要掌握javax.servlet.http.HttpServlet类。javax.servlet.http.HttpServlet类的声明情况如下： 1public abstract class HttpServlet extends GenericServlet implements java.io.Serializable 可见在HttpServlet类中实现了Serializable接口，也就是说已经作了串行化处理，开发人员在继承HttpServlet类后不必再作串行化处理，简化了编程。 HttpServlet类是一个抽象的类，用于创建一个基于HTTP协议的Servlet，在继承它的类中必须实现以下方法中的至少一个： doGet() 此方法通过service()方法被调用，用于在Servlet中处理一个GET请求。在此方法中，开发人员常编写代码来读取请求(request)中的数据，完成响应(response)头中的设置，取得回应的输出流对象，再通过这个输出流对象来输出数据。 1protected void deGet(HttpServlet req,HttpServlet resp) throws ServletException,Java.io.IOException doPost() 此方法通过service()方法被调用，用于在Servlet中处理一个POST请求。方法的其他说明同doGet()方法。 1protected void dePost(HttpServlet req,HttpServlet resp) throws ServletException,Java.io.IOException service() servide()方法接收客户端的请求，并将请求转发给已定义的doXxxx()方法 1protected void service(HttpServlet req,HttpServlet resp) throws ServletException,Java.io.IOException init() 此方法继承自GenericServlet类，用于对Servlet容器中的当前Servlet作初始化处理 1public void init(ServletConfig config) throws ServletException destory() 当前Servlet在生命周期结束时调用此方法 1public void destory() web.xml &lt; web-app &gt; &lt; /web-app &gt;标签 &lt; web-app&gt;&lt; /web-app&gt;是部署描述的根元素，该元素含23个子元素。在Servlet2.3中，子元素必须按照DTD文件描述中指定的顺序出现。比如：如果部署描述符中的&lt; web-app&gt;元素有&lt; servlet&gt;和&lt; servlet-mapping&gt;两个子元素，则&lt; servlet&gt;子元素必须出现在&lt; servlet-mapping&gt;子元素之前。在Servlet2.4中，顺序并不重要。 &lt; display-name&gt;&lt; /display-name&gt;标签 &lt; display-name&gt;&lt; /display-name&gt;定义web应用的名称。如 1&lt;display-name&gt;trk-order-rest&lt;/display-name&gt; &lt; distributable/&gt; &lt; distributable/&gt;可以使用distributable元素来告诉servlet/JSP容器，Web容器中部署的应用程序适合在分布式环境下运行。 &lt; session-config&gt;&lt; /session-config&gt;标签 &lt; session-config&gt; 用于设置容器的session参数，比如：&lt; session-timeout&gt;用于指定http session的失效时间。默认时间设置(30minutes)。&lt; session-timeout&gt;用来指定默认的会话超时时间间隔，以分钟为单位。该元素值为整数。如果 session-timeout元素的值为零或负数，则表示会话将永远不会超时。 123&lt;session-config&gt; &lt;session-timeout&gt;30&lt;ession-timeout&gt;&lt;/session-config&gt; &lt; filter&gt;&lt; /filter&gt;标签 Filter可认为是Servlet的一种“变种”，它主要用于对用户请求(HttpServletRequest)进行预处理,也可以对服务器响应(HttpServletResponse)进行后处理，是个典型的处理链。它与Servlet的区别在于：它不能直接向用户生成响应。完整的流程是：Filter对用户请求进行预处理，接着将请求交给Servlet进行处理并生成响应，最后Filter再对服务器响应进行后处理。 详细了解可以去看看这位大佬的博客：http://www.cnblogs.com/vanl/p/5742501.html &lt; listener&gt;&lt; /listener&gt;标签 监听器Listener就是在application，session，request三个对象创建，销毁，或者往其中添加修改删除属性时自动执行代码的功能组件。Listener是Servlet的监听器，可以监听客户端的请求，服务端的操作等。 详细了解可以去看看这位大佬的博客：http://www.cnblogs.com/vanl/p/5753722.html &lt; servlet&gt;&lt; /servlet&gt;标签 Servlet通常称为服务端小程序，是服务端的程序，用于处理及响应客户的请求。Servlet是一个特殊的Java类，创建Servlet类自动继承HttpServlet。客户端通常只有GET和POST两种请求方式，Servlet为了响应这两种请求，必须重写doGet()和doPost()方法。大部分时候，Servlet对于所有的请求响应都是完全一样的，此时只需要重写service()方法即可响应客户端的所有请求。另外HttpServlet有两个方法: init(ServletConfig config):创建Servlet实例时，调用该方法初始化Servlet资源。 destory():销毁Servlet实例时，自动调用该方法回收资源。 通常无需重写init()和destory()两个方法，除非需要在初始化Servlet时，完成某些资源初始化的方法，才考虑重写init()方法。如果重写了init()方法，应该在重写该方法的第一行调用super.init(config),该方法将调用HttpServlet的init()方法。如果需要在销毁Servlet之前，先完先完成某些资源的回收，比如关闭数据库链接，才需要重写destory()方法。 123456789101112131415161718&lt;servlet&gt; &lt;servlet-name&gt;passwordServer&lt;/servlet-name&gt; //服务器名字 &lt;servlet-class&gt;org.password.server.PasswordServer&lt;/servlet-class&gt;//类&lt;/servlet&gt;&lt;servlet&gt; &lt;servlet-name&gt;personServer&lt;/servlet-name&gt; &lt;servlet-class&gt;org.password.server.PersonServer&lt;/servlet-class&gt;&lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;personServer&lt;/servlet-name&gt;//名字 与上面对应 &lt;url-pattern&gt;/personServer&lt;/url-pattern&gt;//Web访问Servlet时相对路径&lt;/servlet-mapping&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;passwordServer&lt;/servlet-name&gt; &lt;url-pattern&gt;/passwordServer&lt;/url-pattern&gt;&lt;/servlet-mapping&gt; &lt; welcome-file-list&gt; &lt; /welcome-file-list&gt;标签 &lt; welcome-file&gt;用来指定首页文件名称。&lt; welcome-file-list&gt;元素可以包含一个或多个&lt; welcome-file&gt;子元素。如果在第一个&lt; welcome-file&gt;元素中没有找到指定的文件，Web容器就会尝试显示第二个，以此类推。 123&lt;welcome-file-list&gt; &lt;welcome-file&gt;view/login.jsp&lt;/welcome-file&gt;&lt;/welcome-file-list&gt; 简单应用 用Servlet获取表单数据 JSP 1234567891011121314151617181920&lt;%@ page language=&quot;java&quot; import=&quot;java.util.*&quot; pageEncoding=&quot;GB2312&quot;%&gt;&lt;!DOCTYPE HTML PUBLIC &quot;-//W3C//DTD HTML 4.01 Transitional//EN&quot;&gt;&lt;html&gt; &lt;head&gt; &lt;title&gt;用户注册&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;form mathod=&quot;post&quot; action=&quot;${pageContext.request.contextPath}/user&quot; name=&quot;form1&quot;&gt;//${pageContext.request.contextPath}是获取绝对路径 用户注册&lt;br&gt; 用户名:&lt;input type=&quot;text&quot; name=&quot;username&quot; size=&quot;20&quot;&gt;&lt;br&gt; 密&amp;nbsp;码&lt;input type=&quot;password&quot; name=&quot;password&quot; size=&quot;20&quot;&gt;&lt;br&gt; 性别:&lt;input type=&quot;radio&quot; value=&quot;男&quot; name=&quot;sex&quot;&gt;男&lt;input type=&quot;radio&quot; name=&quot;sex&quot; value=&quot;女&quot;&gt;女&lt;br&gt; 电子邮箱:&lt;input name=&quot;email&quot; maxlength=28&gt;&lt;br&gt; 家庭住址:&lt;input type=&quot;text&quot; name=&quot;address&quot; size=&quot;20&quot;&gt;&lt;br&gt; &lt;input type=&quot;submit&quot; value=&quot;提交&quot; name=&quot;b1&quot; &gt;&lt;input type=&quot;reset&quot; value=&quot;全部重写&quot; name=&quot;b2&quot;&gt;&lt;br&gt; &lt;/form&gt; &lt;/body&gt;&lt;/html&gt; web.xml配置 12345678910111213141516171819202122&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;web-app version=&quot;2.5&quot; xmlns=&quot;http://java.sun.com/xml/ns/javaee&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_2_5.xsd&quot;&gt; &lt;display-name&gt;&lt;/display-name&gt; &lt;servlet&gt; &lt;servlet-name&gt;UserRegist&lt;/servlet-name&gt; &lt;servlet-class&gt;test.UserRegist&lt;/servlet-class&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;UserRegist&lt;/servlet-name&gt; &lt;url-pattern&gt;/user&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; &lt;welcome-file-list&gt; &lt;welcome-file&gt;index.jsp&lt;/welcome-file&gt; &lt;/welcome-file-list&gt;&lt;/web-app&gt; Servlet 1234567891011121314151617181920212223242526272829303132333435363738import java.io.IOException;import java.io.PrintWriter;import javax.servlet.ServletException;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;public class UserRegist extends HttpServlet{ public String codeToString(String str){ String s=str; try{ byte temp[]=s.getBytes(&quot;ISO-8859-1&quot;); s=new String(temp); return s; }catch (Exception e){ return s; } } protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { this.doPost(request, response); } protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException{ response.setContentType(&quot;text/html;charset=GB2312&quot;); PrintWriter out=response.getWriter(); out.println(&quot;&lt;html&gt;&lt;head&gt;&lt;title&gt;用户注册&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&quot;); out.println(&quot;这是新用户注册所提交的数据&lt;br&gt;&quot;); out.println(&quot;用户名是:&quot;+codeToString(request.getParameter(&quot;username&quot;))+&quot;&lt;br&gt;&quot;); out.println(&quot;密码是:&quot;+codeToString(request.getParameter(&quot;password&quot;))+&quot;&lt;br&gt;&quot;); out.println(&quot;性别是:&quot;+codeToString(request.getParameter(&quot;sex&quot;))+&quot;&lt;br&gt;&quot;); out.println(&quot;电子邮箱是:&quot;+codeToString(request.getParameter(&quot;email&quot;))+&quot;&lt;br&gt;&quot;); out.println(&quot;家庭住址是:&quot;+codeToString(request.getParameter(&quot;address&quot;))+&quot;&lt;br&gt;&quot;); out.println(&quot;&lt;/body&gt;&lt;/html&gt;&quot;); } }","link":"/2019/05/15/servlet%E6%8A%80%E6%9C%AF/"},{"title":"基于Android端的http、rtsp协议视频流播放器的实现","text":"前言 最近实训根据老师的要求实现了一个Android端的http、rtsp播放器，根据地址连接并播放视频实时流，并附带人脸检测、目标检测等功能，在此重构一下实现过程并总结。 总体分析 首先，需要实现从通过http、rtsp协议发送的视频流中获得视频帧，不然接下来的工作都没法继续。能获取视频帧后就能进行人脸检测或目标检测等工作。所以，获取视频帧至关重要。关于视频帧的获取最初的想法是通过OpenCV-Android来实现，使用VideoCapture直接通过地址打开视频流，然后通过while获取每一帧，但是怎么都打不开( isOpened()总是返回false ) 但是使用JAVA却能打开，通过网上查找资料得知VideoCapture打开媒体的后端是通过ffmpeg实现的。至于Android怎么使用VideoCapture打开视频流，，emmm我还是换个方法吧。根据老师的提示接触到了vlc，但是vlc并没有在java端提供返回视频帧的回调接口，要想使用的话就要修改源码并通过jni暴露给java层使用（过程异常复杂，需要自行修改代码，然后还要自行编译源码，中间的坑数不胜数）。不过，，，在逛github时发现了这位大佬地址，最后使用了他封装好的aar解决了视频帧获取的问题。既然视频帧的问题解决了，人脸检测的话就用OpenCV实现，目标检测使用TensorFlow Lite实现，具体的实现后面再说。 视频流的播放 既然已经可以获取到帧了，那么就通过&lt;ImageView/ &gt;逐帧显示达到播放的效果，Android更新UI需要开一个runOnUiThread来实现 123456runOnUiThread( new Runnable() { @Override public void run() { video_view.setImageBitmap(bitmap);//video_view为&lt;ImageView/ &gt;控件 } }); 显示的问题也解决了，那么怎么通过libvlc获取视频帧，下面是我画的一个大致流程图： 具体实现代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940private void Video_loading(String url){ ArrayList&lt;String&gt; options = new ArrayList&lt;&gt;(); options.add(&quot;--aout=opensles&quot;); options.add(&quot;--audio-time-stretch&quot;); options.add(&quot;-vvv&quot;); mLibVLC = new LibVLC(this,options); media = new Media(mLibVLC, Uri.parse(url)); if (mediaPlayer != null){ mediaPlayer.release(); } mediaPlayer = new MediaPlayer(media); ByteBuffer frameBuffer = ByteBuffer.allocateDirect(Frame_width*Frame_height*Pixel_Size); mediaPlayer.setVideoFormat(&quot;RGBA&quot;,Frame_width,Frame_height, Frame_width*Pixel_Size); mediaPlayer.setVideoCallback(frameBuffer,new VideoCallback());//设置回调接口 mediaPlayer.setMedia(media); media.release(); mediaPlayer.play(); } //回调接口 private class VideoCallback implements MediaPlayCallback{ @Override public void onDisplay(ByteBuffer buffer) { buffer.rewind(); bitmap = Bitmap.createBitmap(Frame_width,Frame_height, Bitmap.Config.ARGB_8888); bitmap.copyPixelsFromBuffer(buffer); showFrame(bitmap); } }//放映 private void showFrame(final Bitmap bitmap){ runOnUiThread( new Runnable() { @Override public void run() { video_view.setImageBitmap(bitmap); } }); } 放映的问题解决了，接下来就是人脸检测以及目标检测。对于这两个的实现无非是在放映之前对帧进行处理，处理完后再放映。 人脸检测 人脸检测的话使用OpenCV实现。使用OpenCV的分类器加载已经训练好的haar级联分类器逐帧检测达到实时检测的效果。至于Android端OpenCV的安装这里不多陈述。大致流程图： 初始化检测器: 我使用的是haarcascade_frontalface_alt.xml，对比了一下其他的发现这个检测速度好像比较快一点(xml文件在：目录/OpenCV-android-sdk\\sdk\\etc 的haarcascades文件夹和lbpcascades文件夹中): 12345678910111213141516171819//初始化人脸检测器 private void initClassifier(){ try { InputStream is = getResources().openRawResource(R.raw.haarcascade_frontalface_alt); File cascadeDir = getDir(&quot;cascade&quot;, Context.MODE_PRIVATE); File cascadeFile = new File(cascadeDir,&quot;haarcascade_frontalface_alt.xml&quot;); FileOutputStream os = new FileOutputStream(cascadeFile); byte[] buffer = new byte[4096]; int bytesRead; while ((bytesRead = is.read(buffer)) != -1){ os.write(buffer,0,bytesRead); } is.close(); os.close(); face_detection = new CascadeClassifier(cascadeFile.getAbsolutePath()); } catch (Exception e){ e.printStackTrace(); } } 进行人脸检测： 使用初始化好的分类器调用detectMultiScale函数进行检测，可以传两个参数： Mat image: 需要检测的图像 MatOfRect objects： 用来存储检测到人脸的位置信息 然后根据MatOfRect的信息绘制检测框： 12345678910111213141516171819//人脸检测private Bitmap onFaceDetection(Bitmap srcBitmap){ Bitmap drawBitmap; Mat src = new Mat(); drawBitmap = Bitmap.createBitmap(srcBitmap.getWidth(),srcBitmap.getHeight(), Bitmap.Config.RGB_565); Utils.bitmapToMat(srcBitmap,src); MatOfRect faceDetections = new MatOfRect(); face_detection.detectMultiScale(src,faceDetections); Log.d(Tag,String.format(&quot;Detected %s faces&quot;, faceDetections.toArray().length)); for(Rect rect : faceDetections.toArray()){ Imgproc.rectangle(src, new Point(rect.x,rect.y), new Point(rect.x+ rect.width,rect.y + rect.height), new Scalar(0,0,255), 3); } Utils.matToBitmap(src,drawBitmap); return drawBitmap;} 在展示视频帧之前调用onFaceDetection函数进行处理后再展示，即可以达到实时人脸检测的效果。 目标检测 目标检测使用TensorFlow Lite实现。模型使用Google已经量化好的SSD模型下载。文件夹下有两个文件，分别为一个.tflite文件（量化之后的SSD模型）以及标签文件。在项目中main下新建assets文件夹并将它们放入。 在build.gradle(app)的android结构下添加以下代码并且添加TensorFlow Lite依赖: 123456789101112android{ ... aaptOptions { noCompress &quot;tflite&quot; noCompress &quot;lite&quot; } ...}dependencies { ... implementation 'org.tensorflow:tensorflow-lite:0.1.7-nightly'} 使用TensorFlow Lite大致流程如下： 1.创建解释器 使用模型需要通过实例化Interpreter对象创建解释器(用来推理模型)。如下： 12345678910111213141516171819202122232425//实例化解释器private Interpreter loadModelFile()throws IOException { AssetFileDescriptor fileDescriptor = getAssets().openFd(modelFileName); FileInputStream inputStream = new FileInputStream(fileDescriptor.getFileDescriptor()); FileChannel fileChannel = inputStream.getChannel(); long startOffset = fileDescriptor.getStartOffset(); long declaredLength = fileDescriptor.getDeclaredLength(); return new Interpreter(fileChannel.map(FileChannel.MapMode.READ_ONLY, startOffset,declaredLength)); }//初始化标签信息private Vector&lt;String&gt; loadModelLabels(){ private Vector&lt;String&gt; labels = new Vector&lt;String&gt;(); //用来存储标签 InputStream labelsInput = null; labelsInput = getAssets().open(labelFileName); BufferedReader br = null; br = new BufferedReader(new InputStreamReader(labelsInput)); String line; while ((line = br.readLine()) != null){ labels.add(line); } br.close(); return labels;} 2.创建Input和Output 在创建Input和Output之前，需要了解模型输入的张量形状以及类型和输出的张量形状以及类型。可以用如下代码得知(Python)： 12345678910import tensorflow as tfinterpreter = tf.lite.Interpreter(model_path=&quot;detect.tflite&quot;)interpreter.allocate_tensors()# Print input shape and ssd_300print(interpreter.get_input_details()[0]['shape']) # Example: [1 300 300 3]print(interpreter.get_input_details()[0]['dtype']) # Example: &lt;class 'numpy.uint8'&gt;# Print output shape and typeprint(interpreter.get_output_details()[0]['shape']) # Example: [1 10 4]print(interpreter.get_output_details()[0]['dtype']) # Example: &lt;class 'numpy.float32'&gt; 在得知Input和Output的形状后，就可以创建Input和Output进行推理。 Input：即为一个视频帧（Bitmap），不过需要处理一下才能作为网络的输入： 123456789101112131415161718192021222324252627282930313233343536private ByteBuffer createInput(final Bitmap bitmap){ int numBytesPerChannel; ByteBuffer imgData; int inputSize = 300; //Float model转化为imgData会用到 float IMAGE_MEAN = 128.0f; float IMAGE_STD = 128.0f; if(isQuantized) numBytesPerChannel = 1; //网络的输入类型为uint8 本次使用的模型输入为uint8 else numBytesPerChannel = 4; //网络的输入类型为float imgData = ByteBuffer.allocateDirect(1 * inputSize * inputSize * 3 * numBytesPerChannel); imgData.order(ByteOrder.nativeOrder()); int[] intValue = new int[inputSize * inputSize]; bitmap.getPixels(intValue,0,bitmap.getWidth(), 0,0, bitmap.getWidth(),bitmap.getHeight()); imgData.rewind(); for (int i = 0; i &lt; inputSize; ++i) { for (int j = 0; j &lt; inputSize; ++j) { int pixelValue = intValue[i * inputSize + j]; if (isQuantized) { // 模型的输入为uint8 imgData.put((byte) ((pixelValue &gt;&gt; 16) &amp; 0xFF)); imgData.put((byte) ((pixelValue &gt;&gt; 8) &amp; 0xFF)); imgData.put((byte) (pixelValue &amp; 0xFF)); } else { //模型的输入为Float 需要转为float imgData.putFloat((((pixelValue &gt;&gt; 16) &amp; 0xFF) - IMAGE_MEAN) / IMAGE_STD); imgData.putFloat((((pixelValue &gt;&gt; 8) &amp; 0xFF) - IMAGE_MEAN) / IMAGE_STD); imgData.putFloat(((pixelValue &amp; 0xFF) - IMAGE_MEAN) / IMAGE_STD); } } } return imgData;}Object[] Input = {createInput(Bitmap inputImage)} Output： 123456789Map&lt;Integer, Object&gt; Output = new HashMap&lt;&gt;();float[][][] outputLocations = new float[1][10][4];// 检测到物体的位置信息float[][] outputClasses = new float[1][10]; //物体的类别float[][] outputScores = new float[1][10]; // 概率float[] numDetections = new float[1]; // 检测到的数量outputMap.put(0, outputLocations);outputMap.put(1, outputClasses);outputMap.put(2, outputScores);outputMap.put(3, numDetections); 进行推理： 使用实例化的Interpreter对象进行推理。 1interpreter.runForMultipleInputsOutputs(inputArray, outputMap); 根据Output绘制检测框 网络输出的结果已经按照scores从大到小排列好了，首先选取scores大于0.5的检测结果，其他的丢掉。先用一张图片试一下，推理完后，先来看一下得分最高的检测信息： 怎么根据这四个信息绘制检测框，我的理解如下； 注释①：检测框的top到原始图像最上方的距离是原始图像height的0.084537685 注释②：检测框的left到原始图像最左方的距离是原始图像width的0.3836609 注释③：检测框的bottom到原始图像最上方的距离是原始图像height的0.9912371 注释④：检测框的right到原始图像最左方的距离是原始图像width的0.6238797 根据以上信息绘制一个检测框： 123456789101112RectF detection = new RectF( outputLocations[0][0][1] * bitmap.getWidth(), //left outputLocations[0][0][0] * bitmap.getHeight(), //top outputLocations[0][0][3] * bitmap.getWidth(), //right outputLocations[0][0][2] * bitmap.getHeight() //bottom );final Canvas canvas = new Canvas(bitmap);final Paint paint = new Paint();paint.setColor(Color.RED);paint.setStyle(Paint.Style.STROKE);paint.setStrokeWidth(2.0f);canvas.drawRect(detection,paint); 如下： 到这里，目标检测算是完成了。 最后总结 通过不断的查找资料和阅读各位大佬的代码，终于将其融合实现了这些功能。这段时间学的东西有点多，所以开篇博客汇总一下。至于播放速率大概有30-40FPS，开启人脸检测后20-25FPS，开启目标检测30-35FPS。效果还能接受。","link":"/2020/01/11/%E5%9F%BA%E4%BA%8EAndroid%E7%AB%AF%E7%9A%84http%E3%80%81rtsp%E5%8D%8F%E8%AE%AE%E8%A7%86%E9%A2%91%E6%B5%81%E6%92%AD%E6%94%BE%E5%99%A8%E7%9A%84%E5%AE%9E%E7%8E%B0/"},{"title":"基于TensorFlow实现mnist数据分类","text":"mnist数据集 MNIST数据集是机器学习领域中非常经典的一个数据集，由60000个训练样本和10000个测试样本组成，每个样本都是一张28 * 28像素的灰度手写数字图片。 一共4个文件依次分别为：测试集、测试集标签、训练集、训练集标签 读入数据 使用TensorFlow中input_data.py脚本来读取数据及标签。 123456789from tensorflow.examples.tutorials.mnist import input_datamnist = input_data.read_data_sets('./data/', one_hot=True) #one_hot 表示采用one_hot的编码方式编码标签# 分成训练以及测试数据trX, trY, teX, teY = mnist.train.images, mnist.train.labels,mnist.test.images, mnist.test.labels# ?个图片28 * 28 一个颜色通道,因为数据是一维的，需要转化成28*28的形式trX = np.reshape(trX, [-1, 28, 28, 1])teX = np.reshape(teX, [-1, 28, 28, 1]) 数据可视化 将前20个图像显示出来。 123456789fig, ax = plt.subplots(nrows=4,ncols=5,sharex='all',sharey='all')#20个子图ax = ax.flatten() #将(4,5)降成(1,20)这样可以更好的将子图添加进去for i in range(20): img = trX[i].reshape(28, 28)#将数据转化为(28,28)的形式 ax[i].imshow(img, cmap='Greys')ax[0].set_xticks([])ax[0].set_yticks([])plt.tight_layout()plt.show() 图像如下 准备搭建卷积神经网络 本次采用3个卷积层和2个全连接层。 卷积函数和最大池化函数 123456789#定义卷积函数def conv2d(x, w, b, k): x = tf.nn.conv2d(x, w, strides=[1, k, k, 1], padding='SAME') x = tf.add(x, b) return tf.nn.relu(x)#定义最大池化函数def maxPool(x, k, s): return tf.nn.max_pool(x, ksize=[1, k, k, 1], strides=[1, s, s, 1], padding='SAME') 权值以及偏差 卷积核都是使用3*3。 123456789101112131415weights = { 'w1': tf.Variable(tf.random_normal([3, 3, 1, 32]), name='w1'), 'w2': tf.Variable(tf.random_normal([3, 3, 32, 64]), name='w2'), 'w3': tf.Variable(tf.random_normal([3, 3, 64, 128]), name='w3'), 'w4': tf.Variable(tf.random_normal([4*4*128, 625]), name='w4'), 'out': tf.Variable(tf.random_normal([625, 10]), name='wout')}biases = { 'b1': tf.Variable(tf.random_normal([32]), name='b1'), 'b2': tf.Variable(tf.random_normal([64]), name='b2'), 'b3': tf.Variable(tf.random_normal([128]), name='b3'), 'b4': tf.Variable(tf.random_normal([625]), name='b4'), 'out': tf.Variable(tf.random_normal([10]), name='bout')} 占位符 1234X = tf.placeholder(tf.float32, [None, 28, 28, 1], 'x')#输入Y = tf.placeholder(tf.float32, [None, 10], 'y')#输出p_conv = tf.placeholder(tf.float32, name='p_conv')#卷积层dropout的比例p_hidden = tf.placeholder(tf.float32, name='p_hidden')#全连接层dropout的比例 损失函数、优化器以及评估模型 1234567# 损失函数cost = tf.reduce_mean(tf.nn.softmax_cross_entropy_with_logits(logits=out, labels=Y))#优化器op = tf.train.AdamOptimizer(0.001).minimize(cost)#评估模型# argmax(array,axis) axis=1取每行最大值的索引，0为取每列最大值的索引。这里表示取每个样本的预测值predict_op = tf.argmax(out, 1, name='predict_op') 搭建卷积神经网络123456789101112131415161718192021222324252627282930313233def model(x, weight, biases, p_conv, p_hidden,): #第一层 c1 = conv2d(x, weights['w1'], biases['b1'], 1) # c1 = [?,28,28,32] c1 = maxPool(c1, 2, 2) # c1 = [?,14,14,32] #第二层 c2 = conv2d(c1, weights['w2'], biases['b2'], 1) # c2 = [?,14,14,64] c2 = maxPool(c2, 2, 2) # c2 = [?,7,7,64] c2 = tf.nn.dropout(c2, p_conv)#按比例杀死一些神经防止过拟合 #第三层 c3_a = conv2d(c2, weights['w3'], biases['b3'], 1) c3 = tf.nn.relu(c3_a) # c3 = [?,7,7,128] c3 = maxPool(c3, 2, 2) # c3 = [?,4,4,128] #全连接层 #转换数据 c3 = [?,4*4*128] c3 = tf.reshape(c3, [-1, weights['w4'].get_shape().as_list()[0]]) c3 = tf.nn.dropout(c3, p_conv) #全连接第一层 c4 = tf.add(tf.matmul(c3, weights['w4']), biases['b4']) c4 = tf.nn.dropout(c4, p_hidden) #输出层 outputs = tf.add(tf.matmul(c4, weights['out']), biases['out'], name='outputs') return outputs 训练以及评估 因为数据量过大，所以采用分批训练。 12345678910111213141516init = tf.global_variables_initializer()with tf.Session() as sess: sess.run(init) saver = tf.train.Saver() for i in range(5): #分批训练 training_batch = zip(range(0, len(trX), batch_size), range(batch_size, len(trX)+1, batch_size)) for start, end in training_batch: sess.run(op, feed_dict={X: trX[start:end], Y:trY[start:end], p_conv: 0.8, p_hidden: 0.5}) test_indices = np.arange(len(teX)) np.random.shuffle(test_indices)#随机打乱 test_indices = test_indices[0:test_size]#获取评估数据 print(i, np.mean(np.argmax(teY[test_indices], axis=1) == sess.run(predict_op, feed_dict={X: teX[test_indices], p_conv: 1.0, p_hidden: 1.0}))) #保存训练的模型 saver.save(sess, 'model/mnist/mnist', global_step=1) 结果如下： 完整代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103import tensorflow as tfimport numpy as npfrom tensorflow.examples.tutorials.mnist import input_datamnist = input_data.read_data_sets('./data/', one_hot=True) #one_hot 表示采用one_hot的编码方式编码标签# 分成训练以及测试数据trX, trY, teX, teY = mnist.train.images, mnist.train.labels,mnist.test.images, mnist.test.labelsweights = { 'w1': tf.Variable(tf.random_normal([3, 3, 1, 32]), name='w1'), 'w2': tf.Variable(tf.random_normal([3, 3, 32, 64]), name='w2'), 'w3': tf.Variable(tf.random_normal([3, 3, 64, 128]), name='w3'), 'w4': tf.Variable(tf.random_normal([4*4*128, 625]), name='w4'), 'out': tf.Variable(tf.random_normal([625, 10]), name='wout')}biases = { 'b1': tf.Variable(tf.random_normal([32]), name='b1'), 'b2': tf.Variable(tf.random_normal([64]), name='b2'), 'b3': tf.Variable(tf.random_normal([128]), name='b3'), 'b4': tf.Variable(tf.random_normal([625]), name='b4'), 'out': tf.Variable(tf.random_normal([10]), name='bout')}# ?个图片28 * 28 一个颜色通道trX = np.reshape(trX, [-1, 28, 28, 1])teX = np.reshape(teX, [-1, 28, 28, 1])X = tf.placeholder(tf.float32, [None, 28, 28, 1], 'x')#输入Y = tf.placeholder(tf.float32, [None, 10], 'y')#输出p_conv = tf.placeholder(tf.float32, name='p_conv')#卷积层dropout的比例p_hidden = tf.placeholder(tf.float32, name='p_hidden')#全连接层dropout的比例#定义卷积函数def conv2d(x, w, b, k): x = tf.nn.conv2d(x, w, strides=[1, k, k, 1], padding='SAME') x = tf.add(x, b) return tf.nn.relu(x)#定义最大池化函数def maxPool(x, k, s): return tf.nn.max_pool(x, ksize=[1, k, k, 1], strides=[1, s, s, 1], padding='SAME')def model(x, weight, biases, p_conv, p_hidden,): #第一层 c1 = conv2d(x, weights['w1'], biases['b1'], 1) # c1 = [?,28,28,32] c1 = maxPool(c1, 2, 2) # c1 = [?,14,14,32] #第二层 c2 = conv2d(c1, weights['w2'], biases['b2'], 1) # c2 = [?,14,14,64] c2 = maxPool(c2, 2, 2) # c2 = [?,7,7,64] c2 = tf.nn.dropout(c2, p_conv) #第三层 c3_a = conv2d(c2, weights['w3'], biases['b3'], 1) c3 = tf.nn.relu(c3_a) # c3 = [?,7,7,128] c3 = maxPool(c3, 2, 2) # c3 = [?,4,4,128] #全连接层 #转换数据 c3 = [?,4*4*128] c3 = tf.reshape(c3, [-1, weights['w4'].get_shape().as_list()[0]]) c3 = tf.nn.dropout(c3, p_conv) #全连接第一层 c4 = tf.add(tf.matmul(c3, weights['w4']), biases['b4']) c4 = tf.nn.dropout(c4, p_hidden) #输出层 outputs = tf.add(tf.matmul(c4, weights['out']), biases['out'], name='outputs') return outputsbatch_size = 128test_size = 512if __name__ == &quot;__main__&quot;: out = model(X, weights, biases, p_conv, p_hidden) # 损失函数 cost = tf.reduce_mean(tf.nn.softmax_cross_entropy_with_logits(logits=out, labels=Y)) #优化器 op = tf.train.AdamOptimizer(0.001).minimize(cost) #评估模型 # argmax(array,axis) axis=1取每行最大值的索引，0为取每列最大值的索引。这里表示取每个样本的预测值 predict_op = tf.argmax(out, 1, name='predict_op') init = tf.global_variables_initializer() with tf.Session() as sess: sess.run(init) saver = tf.train.Saver() for i in range(5): #分批训练 training_batch = zip(range(0, len(trX), batch_size), range(batch_size, len(trX)+1, batch_size)) for start, end in training_batch: sess.run(op, feed_dict={X: trX[start:end], Y:trY[start:end], p_conv: 0.8, p_hidden: 0.5}) test_indices = np.arange(len(teX)) np.random.shuffle(test_indices)#随机打乱 test_indices = test_indices[0:test_size]#获取评估数据 print(i, np.mean(np.argmax(teY[test_indices], axis=1) == sess.run(predict_op, feed_dict={X: teX[test_indices], p_conv: 1.0, p_hidden: 1.0}))) saver.save(sess, 'model/mnist/mnist', global_step=1)","link":"/2019/08/15/%E5%9F%BA%E4%BA%8ETensorFlow%E5%AE%9E%E7%8E%B0mnist%E6%95%B0%E6%8D%AE%E5%88%86%E7%B1%BB/"},{"title":"基于TensorFlow实现线性回归","text":"线性回归模型简介 线性回归，就是能够用一个直线较为精确地描述数据之间的关系。这样当出现新的数据的时候，就能够预测出一个简单的值，确定两种或两种以上变量间相互依赖的定量关系的一种统计分析方法。 分析 这里使用了一个3层的神经网络，如下： 每层的权重以及偏差为： 12345678910111213#每层网络的权重weights = { 'w1': tf.Variable(tf.random_normal([1, 5])), 'w2': tf.Variable(tf.random_normal([5, 3])), 'out': tf.Variable(tf.random_normal([3, 1]))}#每层网络的偏差biases = { 'b1': tf.Variable(tf.random_normal([1, 5])), 'b2': tf.Variable(tf.random_normal([1, 3])), 'out': tf.Variable(tf.random_normal([1,1]))} 生成测试数据 123456789#生成训练数据 Training Data#使用numpy生成200个随机点x_data=np.linspace(-1,1,200)[:, np.newaxis]b=np.random.normal(0,0.2,x_data.shape)y_data=np.square(x_data)+b#查看一下数据plt.scatter(x_data,y_data)plt.show() 数据分布如下图： 网络的搭建 1234567891011121314151617def network(x, weights, biases): #网络第一层 z1 = tf.add(tf.matmul(x, weights['w1']), biases['b1']) a1 = tf.nn.tanh(z1) #使用tanh激活函数 #第二层 z2 = tf.add(tf.matmul(a1, weights['w2']), biases['b2']) a2 = tf.nn.tanh(z2) #使用tanh激活函数 #输出层 z3 = tf.add(tf.matmul(a2, weights['out']), biases['out']) outputs = tf.nn.tanh(z3) return outputs#定义损失函数cost = tf.reduce_mean(tf.square(ys - outputs))#优化函数(这里使用梯度下降法)op = tf.train.GradientDescentOptimizer(learning_rate).minimize(cost) 这里的拟合方法使用的是最小二乘法，它通过最小化误差的平方和寻找数据的最佳函数匹配。利用最小二乘法可以简便地求得未知的数据，并使得这些求得的数据与实际数据之间误差的平方和为最小。简单来说，就是求每个点到曲线的距离平方并相加，这样就得到一个损失值，然后使用梯度下降法优化它。使得它不断的减少，当到达一个临界点时即拟合完成。这里训练1000次，每100次输出当前损失值： 可以看出，当损失值到达0.04时梯度已经非常小了，这时候基本已经拟合。 未训练前 训练完成后 可以看出，经过训练已经拟合了。 完整代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081import tensorflow as tfimport numpy as npimport matplotlib.pyplot as plt#每层网络的权重weights = { 'w1': tf.Variable(tf.random_normal([1, 5])), 'w2': tf.Variable(tf.random_normal([5, 3])), 'out': tf.Variable(tf.random_normal([3, 1]))}#每层网络的偏差biases = { 'b1': tf.Variable(tf.random_normal([1, 5])), 'b2': tf.Variable(tf.random_normal([1, 3])), 'out': tf.Variable(tf.random_normal([1,1]))}#学习率learning_rate = 0.1#训练迭代次数training_epochs = 1000display_step = 100#生成训练数据 Training Data#使用numpy生成200个随机点x_data=np.linspace(-1,1,200)[:, np.newaxis]b=np.random.normal(0,0.2,x_data.shape)y_data=np.square(x_data)+b#查看一下数据plt.scatter(x_data,y_data)plt.show()xs = tf.placeholder(tf.float32, [None, 1])ys = tf.placeholder(tf.float32, [None, 1])def network(x, weights, biases): #网络第一层 z1 = tf.add(tf.matmul(x, weights['w1']), biases['b1']) a1 = tf.nn.tanh(z1) #使用relu激活函数 #第二层 z2 = tf.add(tf.matmul(a1, weights['w2']), biases['b2']) a2 = tf.nn.tanh(z2) #使用relu激活函数 #输出层 z3 = tf.add(tf.matmul(a2, weights['out']), biases['out']) outputs = tf.nn.tanh(z3) return outputsif __name__ == &quot;__main__&quot;: outputs = network(xs, weights, biases) #定义损失函数 cost = tf.reduce_mean(tf.square(ys - outputs)) #优化函数(这里使用梯度下降法) op = tf.train.GradientDescentOptimizer(learning_rate).minimize(cost) #初始化 init =tf.global_variables_initializer() #训练 with tf.Session() as sess: sess.run(init) #未训练前 Y1 = sess.run(network(xs, weights, biases), feed_dict={xs: x_data, ys: y_data}) plt.scatter(x_data, y_data) # 真实的散点值 plt.plot(x_data, Y1, 'r-', lw=3) # 预测值 plt.show() #开始训练 for i in range(training_epochs): sess.run(op, feed_dict={xs: x_data, ys: y_data}) if i%display_step == 0: print(&quot;现在的损失值：%f&quot;%(sess.run(cost, feed_dict={xs: x_data, ys: y_data}))) #获取预测的Y的值 Y = sess.run(network(xs, weights, biases), feed_dict={xs: x_data, ys: y_data}) plt.scatter(x_data,y_data) #真实的散点值 plt.plot(x_data, Y, 'r-', lw=3)#预测值 plt.show()","link":"/2019/07/21/%E5%9F%BA%E4%BA%8ETensorFlow%E5%AE%9E%E7%8E%B0%E7%BA%BF%E6%80%A7%E5%9B%9E%E5%BD%92/"},{"title":"基于TensorFlow实现鸢尾花分类","text":"问题描述本次使用TensorFlow对鸢尾花进行分类，鸢尾花分为三种：Iris Setosa(山鸢尾)、Iris Versicolour (变色鸢尾)以及Iris Virginica(维吉尼亚鸢尾)。 我们通过4个特征值(单位：cm)来进行区分，分别为：sepal length(萼片长度)、sepal width(萼片宽度)、petal length(花瓣长度)、petal width(花瓣宽度)。 获取数据从网上下载数据： 123df = pd.read_csv('https://archive.ics.uci.edu/ml/machine-learning-databases/iris/iris.data', header=None)print(df) 一共有150条数据，每一条分别为4个特征加上标签。 数据处理12345678910#获取数据df = pd.read_csv('https://archive.ics.uci.edu/ml/machine-learning-databases/iris/iris.data', header=None)#提取特征features = df.iloc[1:len(df.index), [0, 1, 2, 3]].values#提取标签labels = df.iloc[1:len(df.index), 4].values# 调节数据,标准化scaler = preprocessing.StandardScaler().fit(features)features_standard = scaler.transform(features) 标准化是指将数据按比例缩放，使之落入一个小的特定区间。 接下来转换一下标签： 山鸢尾-&gt;0 变色鸢尾-&gt;1 维吉尼亚鸢尾-&gt;2 1234567891011 # 转换一下标签 labels1 = [] for i in range(len(labels)): if labels[i] == &quot;Iris-setosa&quot;: labels1.append(0) elif labels[i] == &quot;Iris-versicolor&quot;: labels1.append(1) else : labels1.append(2) #将数据分为训练、测试数据比例0.67 : 0.33 features_train, features_test, labels_train, labels_test =train_test_split(features_standard, labels1,test_size=0.33) 搭建网络开始构建神经网络，本次网络的构建为：4个结点的输入层、2个每层10个结点的隐藏层以及3个结点的输出层。 网络的权重以及偏差 1234567891011121314#权重weights = { 'w1': tf.Variable(tf.random_normal([4, 10])), 'w2': tf.Variable(tf.random_normal([10, 10])), 'w3': tf.Variable(tf.random_normal([10, 10])), 'out': tf.Variable(tf.random_normal([10, 3]))}#偏差biases = { 'b1': tf.Variable(tf.random_normal([1, 10])), 'b2': tf.Variable(tf.random_normal([1, 10])), 'b3': tf.Variable(tf.random_normal([1, 10])), 'b4': tf.Variable(tf.random_normal([1, 3]))} 搭建网络 1234567891011121314151617#TensorFlow中的占位符，用于传入外部数据xs = tf.placeholder(tf.float32, [None, 4])def network(x, weights, biases): #第一层 z1 = tf.add(tf.matmul(x, weights['w1']), biases['b1']) a1 = tf.nn.tanh(z1) #第二层 z2 = tf.add(tf.matmul(a1, weights['w2']), biases['b2']) a2 = tf.nn.tanh(z2) #第三层 z3 = tf.add(tf.matmul(a2, weights['w3']), biases['b3']) a3 = tf.nn.tanh(z3) #输出层 z4 = tf.add(tf.matmul(a3, weights['out']), biases['b4']) outputs = tf.nn.softmax(z4)#最后一层使用softmax激活函数 return outputs 这里说下，softmax激活函数用于多分类，它能将多个神经元的输出，映射到(0,1)区间内，这样就可以看成概率来理解，从而实现多分类。表达式为： 如下面一个神经网络的输出： z1 = w11 * 01 + w21 * o2 + w31 * 03 + w41 * o4 + b1 z2 = w12 * 01 + w22 * o2 + w32 * 03 + w42 * o4 +b2 z3 = w13 * 01 + w23 * o2 + w33 * 03 + w43 * o4 + b3 ps: o1 代表第一个神经元的值 那么经过softmax激活可得： 损失函数以及优化器 123out = network(xs, weights, biases)loss=tf.reduce_mean(tf.nn.sparse_softmax_cross_entropy_with_logits(labels=labels_train, logits=out))op = tf.train.GradientDescentOptimizer(0.1).minimize(loss) 损失函数使用的是交叉熵，它是一个信息论中的概念，它原来是用来估算平均编码长度的。给定两个概率分布yi和yi-，通过yi-来表示yi的交叉熵为: 交叉熵刻画的是两个概率分布之间的距离，或可以说它刻画的是通过概率分布yi-来表达概率分布yi的困难程度，yi代表正确答案，yi-代表的是预测值，交叉熵越小，两个概率的分布约接近。 优化方法使用的是梯度下降。 开始训练 训练1000次，每100次输出当前损失值。 1234567init = tf.global_variables_initializer()with tf.Session() as sess: sess.run(init) for i in range(1000): sess.run(op, feed_dict={xs: features_train}) if i % 100 == 0: print(sess.run(loss, feed_dict={xs: features_train})) 可见损失值到0.56时，梯度已经接近山底。 使用测试数据测试 1234567891011121314 #获取预测值test = sess.run(network(xs, weights, biases), feed_dict={xs: features_test}) sum = 0 for i in range(len(test)): if test[i][0] &gt; test[i][1] and test[i][0] &gt; test[i][2]: if labels_test[i] == 0: sum+=1 elif test[i][1] &gt; test[i][0] and test[i][1] &gt; test[i][2]: if labels_test[i] == 1: sum+=1 else: if labels_test[i] == 2: sum+=1 print(&quot;准确率为 %f&quot; %(sum/len(test))) 可见准确率达到了百分之96。 完整代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586import tensorflow as tfimport numpy as npimport matplotlib.pyplot as pltfrom sklearn.model_selection import train_test_splitfrom sklearn import preprocessingimport pandas as pd#权重weights = { 'w1': tf.Variable(tf.random_normal([4, 10])), 'w2': tf.Variable(tf.random_normal([10, 10])), 'w3': tf.Variable(tf.random_normal([10, 10])), 'out': tf.Variable(tf.random_normal([10, 3]))}#偏差biases = { 'b1': tf.Variable(tf.random_normal([1, 10])), 'b2': tf.Variable(tf.random_normal([1, 10])), 'b3': tf.Variable(tf.random_normal([1, 10])), 'b4': tf.Variable(tf.random_normal([1, 3]))}if __name__ == &quot;__main__&quot;: df = pd.read_csv('iris.data', header=None) features = df.iloc[1:len(df.index), [0, 1, 2, 3]].values labels = df.iloc[1:len(df.index), 4].values # 调节数据,标准化 scaler = preprocessing.StandardScaler().fit(features) features_standard = scaler.transform(features) # 转换一下标签 labels1 = [] for i in range(len(labels)): if labels[i] == &quot;Iris-setosa&quot;: labels1.append(0) elif labels[i] == &quot;Iris-versicolor&quot;: labels1.append(1) else : labels1.append(2) features_train, features_test, labels_train, labels_test = train_test_split(features_standard, labels1, test_size=0.33) #TensorFlow中的占位符，用于传入外部数据 xs = tf.placeholder(tf.float32, [None, 4]) ys = tf.placeholder(tf.float32, [None, 1]) def network(x, weights, biases): #第一层 z1 = tf.add(tf.matmul(x, weights['w1']), biases['b1']) a1 = tf.nn.relu(z1) #第二层 z2 = tf.add(tf.matmul(a1, weights['w2']), biases['b2']) a2 = tf.nn.relu(z2) #输出层 z4 = tf.add(tf.matmul(a2, weights['out']), biases['b4']) outputs = tf.nn.softmax(z4)#最后一层使用softmax激活函数 return outputs out = network(xs, weights, biases) loss = tf.reduce_mean(tf.nn.sparse_softmax_cross_entropy_with_logits(labels=labels_train, logits=out)) op = tf.train.GradientDescentOptimizer(0.1).minimize(loss) init = tf.global_variables_initializer() with tf.Session() as sess: sess.run(init) for i in range(1000): sess.run(op, feed_dict={xs: features_train}) if i % 100 == 0: print(sess.run(loss, feed_dict={xs: features_train})) #获取预测值 test = sess.run(network(xs, weights, biases), feed_dict={xs: features_test}) sum = 0 for i in range(len(test)): if test[i][0] &gt; test[i][1] and test[i][0] &gt; test[i][2]: if labels_test[i] == 0: sum+=1 elif test[i][1] &gt; test[i][0] and test[i][1] &gt; test[i][2]: if labels_test[i] == 1: sum+=1 else: if labels_test[i] == 2: sum+=1 print(&quot;准确率为 %f&quot; %(sum/len(test)))","link":"/2019/07/23/%E5%9F%BA%E4%BA%8ETensorFlow%E5%AE%9E%E7%8E%B0%E9%B8%A2%E5%B0%BE%E8%8A%B1%E5%88%86%E7%B1%BB/"},{"title":"数据结构-二叉树","text":"二叉树是指数的度为2的有序数。它是一种非常重要的数结构，在计算机领域中有着广泛的应用。二叉树的递归定义为：二叉树或者是一颗空数，或者是一颗由一个根结点和两颗互不相交的分别称为根的左子树和右子树所组成的非空树，左子树和右子树又同样都是一颗二叉树。 二叉树的存储结构 同单链表相同，二叉链表既可由独立分配的结点链接而成，也可由数组中的元素结点链接而成。 独立结点12345678910111213public class BTreeNode { Object element; BTreeNode left,rigth; public BTreeNode(Object element){ this.element=element; left=rigth=null; } public BTreeNode(Object element,BTreeNode left,BTreeNode rigth){ this.element=element; this.left=left; this.rigth=rigth; }} 元素结点123456789101112public class ABTreeNode { Object element; int left,rigth; public ABTreeNode(Object element){ this.element=element; } public ABTreeNode(Object element,int left,int rigth){ this.element=element; this.left=left; this.rigth=rigth; }} 二叉树的方法创建二叉树1234567891011121314151617181920public void creat(){ System.out.println(&quot;请按照树的先序遍历顺序组织数据&quot;); System.out.println(&quot;一个结点的二叉树11，输入：11 0 0&quot;); root=creat0();}private BTreeNode creat0(){ //递归构造 二叉树 BTreeNode p; int date; System.out.print(&quot;输入数据:&quot;); date=in.nextInt(); if(date==0){ p=null; }else{ p=new BTreeNode(date); p.left=creat0(); p.rigth=creat0(); } return p;} 二叉树遍历 先序遍历 1234567public void preOrder(BTreeNode bt){ //先序遍历二叉树 if(bt!=null){ System.out.print(bt.element+&quot; &quot;); preOrder(bt.left); preOrder(bt.rigth); }} 中序遍历 1234567public void inOrder(BTreeNode bt){ //中序遍历二叉树 if(bt!=null){ preOrder(bt.left); System.out.print(bt.element+&quot; &quot;); preOrder(bt.rigth); } } 后序遍历 1234567public void postOrder(BTreeNode bt){ //后序遍历二叉树 if(bt!=null){ preOrder(bt.left); preOrder(bt.rigth); System.out.print(bt.element+&quot; &quot;); }} 层次遍历 1234567891011public void levelOrder(BTreeNode bt){ //层次遍历二叉树 Queue que=new LinkedList();// 创建一个队列 BTreeNode p=null; que.add(bt); //添加 while(!que.isEmpty()){ p=(BTreeNode)que.poll();//取出第一个并且删除 System.out.print(p.element+&quot; &quot;); if(p.left!=null) que.add(p.left);//如果左子树不为空，在队尾添加 if(p.rigth!=null) que.add(p.rigth);//如果右子树不为空,在队尾添加 }} 其他方法 判断二叉树是否为空 123public boolean isEmpty(){ //判断二叉树是否为空 return root==null;} 求二叉树的深度 123456789101112public int depthBTree(BTreeNode bt){ //求二叉树的深度 if(bt==null) return 0; //空结点，返回0并结束递归 else{ int left=depthBTree(bt.left); //计算左子树的深度 int rigth=depthBTree(bt.rigth); //计算右子树的深度 if(left&gt;rigth) return left+1; else return rigth+1; }} 求二叉树中的结点数 1234567891011121314151617181920public int countBTree(BTreeNode bt){ //求二叉树中的结点数 if(bt==null) return 0; //若结点为空 返回0 ，否则它等于左子树中的结点树与右子树中的结点数之和加一，这个一表示根结点 else return countBTree(bt.left)+countBTree(bt.rigth)+1;}public int findBTree(BTreeNode bt,int x){//从二叉树查找值为x的结点，若存在则返回该结点的完整值 if(bt==null) return -1; else{ if(bt.element==x) return bt.element; else{ int y; y=findBTree(bt.left, x); if(y!=-1) return y;//左子树查找 y=findBTree(bt.rigth, x); if(y!=-1) return y;//右子树查找 return -1; } }} 清除二叉树 123public void cleatBTree(){ //清除二叉树 root=null;} 实现代码 结点12345678910111213public class BTreeNode { int element; BTreeNode left,rigth; public BTreeNode(int element){ this.element=element; left=rigth=null; } public BTreeNode(int element,BTreeNode left,BTreeNode rigth){ this.element=element; this.left=left; this.rigth=rigth; }} 二叉树123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115import java.util.LinkedList;import java.util.Queue;import java.util.Scanner;public class linkBinaryTree { protected BTreeNode root; private Scanner in =new Scanner(System.in); public linkBinaryTree(){ //无参构造函数 root=null; } public BTreeNode getRoot(){ //返回树根指针的值 return root; } public void creat(){ System.out.println(&quot;请按照树的先序遍历顺序组织数据&quot;); System.out.println(&quot;一个结点的二叉树11，输入：11 0 0&quot;); root=creat0(); } private BTreeNode creat0(){ //递归构造 二叉树 BTreeNode p; int date; System.out.print(&quot;输入数据:&quot;); date=in.nextInt(); if(date==0){ p=null; }else{ p=new BTreeNode(date); p.left=creat0(); p.rigth=creat0(); } return p; } public void preOrder(BTreeNode bt){ //先序遍历二叉树 if(bt!=null){ System.out.print(bt.element+&quot; &quot;); preOrder(bt.left); preOrder(bt.rigth); } } public void inOrder(BTreeNode bt){ //中序遍历二叉树 if(bt!=null){ preOrder(bt.left); System.out.print(bt.element+&quot; &quot;); preOrder(bt.rigth); } } public void postOrder(BTreeNode bt){ //后序遍历二叉树 if(bt!=null){ preOrder(bt.left); preOrder(bt.rigth); System.out.print(bt.element+&quot; &quot;); } } public void levelOrder(BTreeNode bt){ //层次遍历二叉树 Queue que=new LinkedList();// 创建一个队列 BTreeNode p=null; que.add(bt); //添加 while(!que.isEmpty()){ p=(BTreeNode)que.poll();//取出第一个并且删除 System.out.print(p.element+&quot; &quot;); if(p.left!=null) que.add(p.left);//如果左子树不为空，在队尾添加 if(p.rigth!=null) que.add(p.rigth);//如果右子树不为空,在队尾添加 } } public boolean isEmpty(){ //判断二叉树是否为空 return root==null; } public int depthBTree(BTreeNode bt){ //求二叉树的深度 if(bt==null) return 0; //空结点，返回0并结束递归 else{ int left=depthBTree(bt.left); //计算左子树的深度 int rigth=depthBTree(bt.rigth); //计算右子树的深度 if(left&gt;rigth) return left+1; else return rigth+1; } } public int countBTree(BTreeNode bt){ //求二叉树中的结点数 if(bt==null) return 0; //若结点为空 返回0 ，否则它等于左子树中的结点树与右子树中的结点数之和加一，这个一表示根结点 else return countBTree(bt.left)+countBTree(bt.rigth)+1; } public int findBTree(BTreeNode bt,int x){//从二叉树查找值为x的结点，若存在则返回该结点的完整值 if(bt==null) return -1; else{ if(bt.element==x) return bt.element; else{ int y; y=findBTree(bt.left, x); if(y!=-1) return y;//左子树查找 y=findBTree(bt.rigth, x); if(y!=-1) return y;//右子树查找 return -1; } } } public void cleatBTree(){ //清除二叉树 root=null; } }","link":"/2019/05/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E4%BA%8C%E5%8F%89%E6%A0%91/"},{"title":"数据结构-线性表-链接存储","text":"概述 在链接存储中，每个存储结点不仅含有所存元素本身的信息，而且含有元素之间逻辑关系的信息，其存储结点的结构为date域(值域),next(指针域)，每个指针域的值为其对应的后继元素或前驱元素所在结点(以后简称为后继结点或前驱结点)的引用(存储位置)。通过结点的指针域可以访问到对应的后继结点或前驱结点，该后继结点或前驱结点称为指针域所指向的结点。若一个结点中的某个指针域不需要指向任何结点，则令它的值为空(null)。 结点类定义123456789public class Node { Object date; //数值域 Node next; //指针域 public Node(Node nextval){next=nextval;} public Node(Object obj,Node nextval){ date=obj; next=nextval; }} 成员以及操作12345678910111213141516private Node head;private int length; //成员public interface List {//操作 public Object value(int n);//返回表中第n个元素的值 public boolean add(Object obj,int n);//向第n个位置插入元素 public Object remove(int n);//删除第n个元素并返回 public int find(Object obj,int n);//从第n个位置起查找元素 public boolean modify(Object obj,int n);//修改给定位置的元素值 public boolean isEmpty();//判断表是否为空 public int size();//返回表的长度 public void nextOrder();//后继遍历表中的每个元素 public void preOrder();//前驱遍历表中的每个元素 public void clear();//清除表中的所有元素，使之为空表 public linkList sort();} 操作实现 这里只演示单链表的实现(JAVA) 1.构造函数12345public linkList(){//无参的构造函数 length=0; head=new Node(null); head.next=head;//形成单链接循环空表 } 2.得到表中第n个元素的值123456789101112public Object value(int n) {//返回表中第n个元素的值 if(n&lt;1||n&gt;length){ System.out.println(&quot;参数n的值不合法！&quot;); return null; } int num=1; Node p=head.next; while(num&lt;n){ num++; p=p.next; } return p.date; } 3.向表中给定位置上插入一个元素123456789101112131415public boolean add(Object obj, int n) {//向第n个位置插入元素 if(n&lt;1||n&gt;length+1){ System.out.println(&quot;参数n的值不合法！&quot;); return false; } int num=1; Node p=head,q=head.next; while(num&lt;n){ p=q; q=q.next; num++; } p.next=new Node(obj,q); length++; return true; } 4.从表中删除给定位置上的元素123456789101112131415public Object remove(int n) {//删除第n个元素并返回 if(n&lt;1||n&gt;length){ System.out.println(&quot;参数n的值不合法！&quot;); return null; } int num=1; Node p=head,q=head.next; while(num&lt;n){ num++; p=q; q=q.next; } p.next=q.next; length--; return q.date; } 5.从表中指定位置开始按值查找对应的第一个元素并返回所在位置123456789101112131415161718public int find(Object obj, int n) {//从第n个位置起查找元素 if(n&lt;1||n&gt;length){ System.out.println(&quot;参数n的值不合法！&quot;); return -1; } int num=1; Node p=head.next; while(num&lt;n){ num++; p=p.next; } while(p!=head&amp;&amp;p.date.equals(obj)==false){ num++; p=p.next; } if(p==head) return -1; else return num; } 6.修改表中给定位置的元素值12345678910111213public boolean modify(Object obj, int n) {//修改给定位置的元素值 if(n&lt;1||n&gt;length){ System.out.println(&quot;参数n的值不合法！&quot;); return false; } int num=1; Node p=head.next; while(num&lt;n){ num++; p=p.next; } p.date=obj; return true; } 7.判断表是否为空123public boolean isEmpty() {//判断表是否为空 return length==0; } 8.求出表长度123public int size() {//返回表的长度 return length; } 9.正序遍历表中所有元素1234567public void nextOrder() {//正序遍历表中的每个元素 Node p=head.next; while(p!=head){ System.out.print(p.date.toString()+&quot; &quot;); p=p.next; } } 10.反序遍历表中的所有元素1234567891011public void preOrder() {//反序遍历表中的每个元素 Object ar[]=new Object[length]; int i=0; Node p=head.next; while(p!=head){ ar[i++]=p.date; p=p.next; } for(i=length-1;i&gt;=0;i--) System.out.print(ar[i].toString()+&quot; &quot;); } 11.清除表中所有元素使之为空表1234public void clear() {//清除表中的所有元素，使之为空表 length=0; head.next=head; } 12.根据链表产生一个新的有序表并返回1234567891011121314151617181920public linkList sort() {//根据链表产生一个新的有序表并返回 linkList list; list=new linkList(); Node n=head.next; Comparable x,y; while(n!=head){ x=(Comparable)n.date; Node p=list.head,q=p.next; while(q!=list.head){ y=(Comparable)q.date; if(x.compareTo(y)&lt;0) break; p=q; q=q.next; } p.next=new Node(n.date,q); list.length++; n=n.next; } return list; } 整体代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143public class linkList implements List{ private Node head; //表头指针 private int length; //表当前长度 public linkList(){//无参的构造函数 length=0; head=new Node(null); head.next=head;//形成单链接循环空表 } public Object value(int n) {//返回表中第n个元素的值 if(n&lt;1||n&gt;length){ System.out.println(&quot;参数n的值不合法！&quot;); return null; } int num=1; Node p=head.next; while(num&lt;n){ num++; p=p.next; } return p.date; } public boolean add(Object obj, int n) {//向第n个位置插入元素 if(n&lt;1||n&gt;length+1){ System.out.println(&quot;参数n的值不合法！&quot;); return false; } int num=1; Node p=head,q=head.next; while(num&lt;n){ p=q; q=q.next; num++; } p.next=new Node(obj,q); length++; return true; } public Object remove(int n) {//删除第n个元素并返回 if(n&lt;1||n&gt;length){ System.out.println(&quot;参数n的值不合法！&quot;); return null; } int num=1; Node p=head,q=head.next; while(num&lt;n){ num++; p=q; q=q.next; } p.next=q.next; length--; return q.date; } public int find(Object obj, int n) {//从第n个位置起查找元素 if(n&lt;1||n&gt;length){ System.out.println(&quot;参数n的值不合法！&quot;); return -1; } int num=1; Node p=head.next; while(num&lt;n){ num++; p=p.next; } while(p!=head&amp;&amp;p.date.equals(obj)==false){ num++; p=p.next; } if(p==head) return -1; else return num; } public boolean modify(Object obj, int n) {//修改给定位置的元素值 if(n&lt;1||n&gt;length){ System.out.println(&quot;参数n的值不合法！&quot;); return false; } int num=1; Node p=head.next; while(num&lt;n){ num++; p=p.next; } p.date=obj; return true; } public boolean isEmpty() {//判断表是否为空 return length==0; } public int size() {//返回表的长度 return length; } public void nextOrder() {//正序遍历表中的每个元素 Node p=head.next; while(p!=head){ System.out.print(p.date.toString()+&quot; &quot;); p=p.next; } } public void preOrder() {//反序遍历表中的每个元素 Object ar[]=new Object[length]; int i=0; Node p=head.next; while(p!=head){ ar[i++]=p.date; p=p.next; } for(i=length-1;i&gt;=0;i--) System.out.print(ar[i].toString()+&quot; &quot;); } public void clear() {//清除表中的所有元素，使之为空表 length=0; head.next=head; } public linkList sort() {//根据链表产生一个新的有序表并返回 linkList list; list=new linkList(); Node n=head.next; Comparable x,y; while(n!=head){ x=(Comparable)n.date; Node p=list.head,q=p.next; while(q!=list.head){ y=(Comparable)q.date; if(x.compareTo(y)&lt;0) break; p=q; q=q.next; } p.next=new Node(n.date,q); list.length++; n=n.next; } return list; } }","link":"/2019/05/02/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E7%BA%BF%E6%80%A7%E8%A1%A8-%E9%93%BE%E6%8E%A5%E5%AD%98%E5%82%A8/"},{"title":"数据结构-线性表-顺序存储","text":"概述 线性表的顺序存储的基本方法是定义一个数组类型的对象来存储集合元素，同时还要定义一个整型对象来存储集合的长度，以及定义一个整型常量对象来保存待定义数组的初始长度。 123final int maxSize=20; //假定存储集合的数组的初始长度为20private Object setArray[]; //定义存储集合的数组的引用对象private int length;//定义数组中所保存集合的当前长度 操作实现1.初始化 通过构造函数，初始化集合为空，并保存集合的数组setArray定义对象。构造函数有两个，一个无参构造函数，另一个为带有数组初始长度参数的构造函数。定义如下: 12345678910111213public Set(){ //无参构造函数 length=0; setArray=new Object[maxSize];}public Set(int n){//带初始长度参数的构造函数 if(n&lt;=0){ System.out.println(&quot;数组长度必须大于0!&quot;); System.exit(1); } length=0; setArray=new Object[n];} 2.向集合插入一个元素12345678910111213141516public boolean add(Object ob,int n){ //向线性表给定位置插入一个元素 if(n&lt;1||n&gt;length+1){ System.out.println(&quot;参数不合法！&quot;); return false; } if(length==setArray.length){//数组空间已经用完 Object b[]=new Object[length*2]; //扩充 for(int i=0;i&lt;length;i++) b[i]=setArray[i]; //复制 setArray=b; } for(int i=length;i&gt;=n;i--) setArray[i]=setArray[i-1]; setArray[n-1]=ob; length++; return true; } 3.从集合里删除一个元素12345678910public boolean remove(Object ob){ int i; for(i=0;i&lt;length;i++) //查找待删除的元素 if(setArray[i].equals(ob)) break; if(i&lt;length){ setArray[i]=setArray[length-1];//把集合最后一个元素赋给被删元素的位置 length--; return true; }else return false; } 4.判断一个元素是否属于集合12345public boolean contains(Object ob){ for(int i=0;i&lt;length;i++) if(setArray[i].equals(ob)) return true; return false; } 5.返回集合第i个元素的值1234567public Object value(int i){ if(i&lt;=0||i&gt;length){ System.out.println(&quot;i应该在1和&quot;+length+&quot;之间&quot;); return null; } return setArray[i-1];//第i个元素对应下标为i-1 } 6.从集合中按值查找元素12345public Object find(Object ob){//从集合中按值查找元素 for(int i=0;i&lt;length;i++) if(setArray[i].equals(ob)) return setArray[i]; return null; } 7.返回集合的长度1public int size(){return length;} 8.判断集合是否为空1public boolean isEmpty(){return length==0;} 9.输出集合中所有元素12345public void output(){//输出集合中所有元素 for(int i=0;i&lt;length;i++) System.out.print(setArray[i].toString()+&quot; &quot;); System.out.println(); } 10.求两个集合的并集12345678910public Set union(Set set){// 求两个集合的并集 Set setTemp=new Set(setArray.length); int i; for(i=0;i&lt;length;i++) setTemp.setArray[i]=setArray; setTemp.length=length; for(i=0;i&lt;set.length;i++) setTemp.add(set.setArray[i]); return setTemp; } 11.求两个集合的交集123456789public Set intersection(Set set){//求两个集合的交集 int x; if(length&lt;set.length) x=length;else x=set.length; Set setTemp=new Set(x); for(int i=0;i&lt;set.length;i++) if(contains(set.setArray[i])) setTemp.setArray[setTemp.length++]=set.setArray[i]; return setTemp; } 12.清除集合中所有元素1public void clear(){length=0;} //清除集合所有元素 实现代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788public class Set { final int maxSize=20; //假定存储集合的数组的初始长度为20 private Object setArray[]; //定义存储集合的数组的引用对象 private int length;//定义数组中所保存集合的当前长度 public Set(){ length=0; setArray=new Object[maxSize]; } public Set(int n){ if(n&lt;=0){ System.out.println(&quot;数组长度必须大于0!&quot;); System.exit(1); } length=0; setArray=new Object[n]; } public boolean add(Object ob){ for(int i=0;i&lt;length;i++) if(setArray[i].equals(ob)) return false; //元素已经存在 if(length==setArray.length){//数组空间已经用完 Object b[]=new Object[length*2]; //扩充 for(int i=0;i&lt;length;i++) b[i]=setArray[i]; //复制 setArray=b; } setArray[length]=ob; length++; return true; } public boolean remove(Object ob){ int i; for(i=0;i&lt;length;i++) //查找待删除的元素 if(setArray[i].equals(ob)) break; if(i&lt;length){ setArray[i]=setArray[length-1];//把集合最后一个元素赋给被删元素的位置 length--; return true; }else return false; } public boolean contains(Object ob){ //判断一个元素是否属于集合 for(int i=0;i&lt;length;i++) if(setArray[i].equals(ob)) return true; return false; } public Object value(int i){ //返回集合中第i个元素 if(i&lt;=0||i&gt;length){ System.out.println(&quot;i应该在1和&quot;+length+&quot;之间&quot;); System.exit(1); } return setArray[i-1];//第i个元素对应下标为i-1 } public Object find(Object ob){//从集合中按值查找元素 for(int i=0;i&lt;length;i++) if(setArray[i].equals(ob)) return setArray[i]; return null; } public int size(){return length;}//返回集合的长度 public boolean isEmpty(){return length==0;}//判断集合是否为空 public void output(){//输出集合中所有元素 for(int i=0;i&lt;length;i++) System.out.print(setArray[i].toString()+&quot; &quot;); System.out.println(); } public Set union(Set set){// 求两个集合的并集 Set setTemp=new Set(setArray.length); int i; for(i=0;i&lt;length;i++) setTemp.setArray[i]=setArray[i]; setTemp.length=length; for(i=0;i&lt;set.length;i++) setTemp.add(set.setArray[i]); return setTemp; } public Set intersection(Set set){//求两个集合的交集 int x; if(length&lt;set.length) x=length;else x=set.length; Set setTemp=new Set(x); for(int i=0;i&lt;set.length;i++) if(contains(set.setArray[i])) setTemp.setArray[setTemp.length++]=set.setArray[i]; return setTemp; } public void clear(){length=0;} //清除集合所有元素 }","link":"/2019/05/01/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E7%BA%BF%E6%80%A7%E8%A1%A8-%E9%A1%BA%E5%BA%8F%E5%AD%98%E5%82%A8/"},{"title":"深度学习-激活函数","text":"激活函数的作用 激活函数的作用主要是增加神经网络的非线性。神经网络的每一层都有矩阵相乘，如果不使用激活函数，每一层的输出都是上层输入的线性函数，无论神经网络有多少层，输出都是线性组合，并没有办法解决非线性问题。所以必须引入非线性函数作为激活函数，这样深层神经网络就有意义了，并可以解决线性模型所不能解决的问题。 Sigmoid公式定义： 导数公式： 函数以及导数图像如下： ps：红色为函数图像，蓝色为导数图像 可以看出Sigmoid的取值范围为(0,1)，它可以将一个实数映射到(0,1)的区间，可以用于输入的归一化。同时，Sigmoid函数求导比较容易，可以直接推导得出。 但是，从导数图像可以看出，当x趋向于正无穷或者负无穷时，导数趋向于0。具有这种性质的称为软饱和激活函数。在反向传播的过程中，一旦输入落入饱和区，导数就会接近于0，导致向后面传递的梯度也会变得非常小。这样的话网络参数就会很难得到有效的训练。这种现象称之为梯度消失。 Tanh公式定义： 导数公式： 函数以及导数图像如下： ps：红色为函数图像，蓝色为导数图像 可以看出，Tanh的输出是以0为中心的，所以收敛速度要比sigmoid快，减少了迭代次数。然而从导数图像可以看出，tanh一样具有软饱和性，从而使得梯度消失。 ReLU ReLU函数又称为修正线性单元，是一种分段线性函数，弥补了sigmoid函数和tanh函数的梯度消失问题。 公式定义： 导数公式： 图像如下： 由上图可看出，ReLU函数是一个分段性函数，把所有负值都变为0，而正值不改变，这种操作称之为单侧抑制。这样就能使得神经网络中的神经元具有了稀疏激活性，防止过度拟合。而且ReLU函数的非负区间的梯度为常数，因此不会存在梯度消失的问题，使得模型的收敛速度维持在一个稳定状态。在使用RuLU函数时，learning rate不能设置很大，否则很有可能使得你网络中的40%的神经元坏死。所以在使用Ru LU函数时，尽量选择一个合适的较小的learning rate。 Leaky ReLULeaky ReLU函数又称为PReLU函数，是通过ReLU改进的函数。公式定义如下： 其中a的取值为(0,1)之间。 导数公式： 图像如下： Leaky ReLU函数解决了ReLU函数在输入为负的情况下产生的梯度消失问题。 SoftmaxSoftmax函数又称归一化指数函数，用于多分类神经网络输出。其公式定义如下： Sigmoid就是类别为2的Softmax。相对于Sigmoid来说，Softmax的结果之和一定唯一并且定义域为一个一维向量。如： 1234test = [8.2, 6.8, 0.7, 1.5]out = tf.nn.softmax(s)with tf.Session() as sess: print(sess.run(tf.nn.softmax(test))) 输出： ps：8.0103743e-01为8.0103743乘以0.1，其他三个类似。 如何选择激活函数 通常来说，不能把各种激活函数串起来在一个网络中使用。如果使用ReLU，那么一定要小心设置学习率，防止网络中出现过多的死亡神经元。如果神经元死亡过多这个解决不了，可以试试Leaky ReLU。尽量不要使用Sigmoid激活函数，目前主流一般都是使用ReLU激活函数。如何搭建一个多分类的神经元，在最终输出使用Softmax激活函数。","link":"/2019/07/20/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0-%E6%BF%80%E6%B4%BB%E5%87%BD%E6%95%B0/"},{"title":"我的第一篇博客","text":"这是我的第一篇博客，其实很早以前就有写博客的想法，不过因为种种原因而导致搁浅。 现在总算是开始了我的博客之旅，希望我能坚持下去。 为什么要写博客 因为经常在网上查找资料，看过很多大牛写的博客，于是就萌生了写博客的想法。同时也是把自己的学习记录下来，有助于自己复习和巩固吧。 会写一些什么 主要还是把对一些知识的见解以及理解表达出来，其次吗，看情况吧，什么七七八八的东西应该都会写。","link":"/2019/04/14/%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2/"},{"title":"算法-动态规划","text":"概述 动态规划处理的对象是多阶段策略问题。 多阶段策略问题，是指这样的一类特殊的活动过程，问题可以分解成若干相互联系的阶段，在每一个阶段都要做出决策，形成一个决策序列，该决策序列也称为一个策略。对于每一个决策序列，可以在满足问题的约束条件下用一个数值函数衡量该策略的优劣。多阶段策略问题的最优化目标是获取导致问题最优值的最优决策序列即得到最优解。 应用动态规划设计使多阶段决策过程达到最优(成本最省、效益最高、路径最短)，依据动态规划的最优性原理: 作为整个过程的最优策略具有这样的性质，无论过去的状态和决策如何，对前面的决策所形成的状态而言，余下的诸决策必须构成最优策略。也就是说，最优决策序列中的任何子序列都是最优的。 动态规划实施步骤 把所求最优化问题分成若干阶段，找出最优解的性质，并刻画其结构特性 最优子结构特性是动态规划求解问题的必要条件，只有满足最优子结构特性的多阶段决策问题才能应用动态规划设计步骤。 将问题发展到各个阶段时所处不同的状态表示出来，确定各个阶段状态之间的递推(或递归)关系，并确定初始条件。 通过设置相应的函数表示各个阶段的最优值，分析归纳出各个阶段状态之间的转移关系，是应用动态规划设计求解的关键。 应用递推(或递归)求解最优值 递推(或递归)计算最优值是动态规划算法的实施过程。具体应用与所设置的表示各个阶段最优值的函数密切相关。 根据计算最优值时所得到的信息，构造最优解 构造最优解就是具体求出最优决策序列。通常在计算最优值时，根据问题的具体实际记录必要的信息，根据所记录的信息构造出问题的最优解。 以上步骤前3个是动态规划设计求解最优化问题的基本步骤。当只需求解最优值时，第4个步骤可以省略。若需求出问题的最优解，则必须执行第4个步骤。 相关例题 1.最优路径搜索 点数值三角形是一个二维数组：三角形由n行构成，第k行有k个点，每一个点都带有一个数值。寻找从顶点开始每一步可沿左斜或右斜向下至底的一条路径，使该路径所经过的点的数值和最小。 比如输入n为3，三角形为： 口 口 口 口 口 口 分析 建立数组dp[i] [j] 表示点(i,j)到底的最小数值和，从下往上推，状态转移方程为: dp[i] [j]=ar[i] [j]+min{dp[i+1] [j],dp[i+1] [j+1]} dp[0] [0]即为问题的解 代码123456789101112131415161718192021222324import java.util.Scanner;public class 最优路劲搜索_动态规划 { static int dp[][]; static int ar[][]; static int n; public static void main(String[] args) { Scanner in =new Scanner(System.in); n=in.nextInt(); dp=new int [30][30]; ar=new int [30][30]; for(int i=0;i&lt;n;i++) for(int j=0;j&lt;=i;j++) ar[i][j]=in.nextInt(); dp(); System.out.println(dp[0][0]); } public static void dp(){ for(int i=n-1;i&gt;=0;i--) for(int j=0;j&lt;=i;j++) dp[i][j]=ar[i][j]+Math.min(dp[i+1][j], dp[i+1][j+1]); }} 2.矩阵权值最长路径 一个矩阵从(1,1)出发 到(m,n)找出权值最大的路径，只能往下或往右走。 分析 建立dp[i] [j]表示从(1,1)走到点(i,j)的权值最大的路径，因为只能往下或往右走，状态转移方程为: dp[i] [j]=list[i] [j]+max{dp[i-1] [j],dp[i] [j-1]} dp[m] [n]即为问题解 1234567891011121314151617181920212223242526import java.util.Scanner;public class 矩阵权值最长路径 { static int n,m; static int dp[][],list[][]; public static void main(String[] args){ Scanner in=new Scanner(System.in); n=in.nextInt(); m=in.nextInt(); list=new int [n+1][m+1]; dp=new int [n+1][m+1]; for(int q=1;q&lt;=n;q++) for(int w=1;w&lt;=m;w++) list[q][w]=in.nextInt(); for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=m;j++) dp[i][j]=max(dp[i][j-1],dp[i-1][j])+list[i][j]; System.out.println(dp[n][m]); } static int max(int x,int y){ if(x&gt;y) return x; else return y; }} 3.传球游戏【问题描述】 上体育课的时候，小蛮的老师经常带着同学们一起做游戏。这次，老师带着同学们一起做传球游戏。 游戏规则是这样的：n个同学站成一个圆圈，其中的一个同学手里拿着一个球，当老师吹哨子时开始传球，每个同学可以把球传给自己左右的两个同学中的一个（左右任意），当老师再次吹哨子时，传球停止，此时，拿着球没传出去的那个同学就是败者，要给大家表演一个节目。 聪明的小蛮提出一个有趣的问题：有多少种不同的传球方法可以使得从小蛮手里开始传的球，传了m次以后，又回到小蛮手里。两种传球的方法被视作不同的方法，当且仅当这两种方法中，接到球的同学按接球顺序组成的序列是不同的。比如有3个同学1号、2号、3号，并假设小蛮为1号，球传了3次回到小蛮手里的方式有1-&gt;2-&gt;3-&gt;1和1-&gt;3-&gt;2-&gt;1，共2种。 输入格式 共一行，有两个用空格隔开的整数n，m（3&lt;=n&lt;=30，1&lt;=m&lt;=30）。 输出格式 t共一行，有一个整数，表示符合题意的方法数。 样例输入 3 3 样例输出 2 分析 建立dp[i] [j] 表示传i次传到j手中，初始条件dp[0] [1]=1;(传0次传到1手中),状态转移方程: j==1(传到1手中), dp[i] [j]= dp[i-1] [n] (传i-1次传到n，因为队列是循环的，n之后又回到1)+dp[i-1] [2] (传i-1次传到2，2也可以传到1) j==n(传到n手中,n可以从n-1和1传到) ，dp[i] [j]=dp[i-1] [n-1]+dp[i-1] [1] 其他, dp[i] [j]=dp[i-1] [j-1]+dp[i-1] [j+1] dp[m] [1] (传m次传到1)即为答案 代码12345678910111213141516171819import java.util.Scanner;public class 传气球_动态规划 { static int m,n; static int dp[][]; public static void main(String[] args) { Scanner in =new Scanner(System.in); n=in.nextInt(); m=in.nextInt(); dp=new int [40][40]; dp[0][1]=1; for(int i=1;i&lt;=m;i++) for(int j=1;j&lt;=n;j++){ if(j==1) dp[i][j]=dp[i-1][n]+dp[i-1][2]; else if(j==n) dp[i][j]=dp[i-1][n-1]+dp[i-1][1]; else dp[i][j]=dp[i-1][j-1]+dp[i-1][j+1]; } System.out.println(dp[m][1]); }} 4.结点选择(树形动态规划)问题描述 有一棵 n 个节点的树，树上每个节点都有一个正整数权值。如果一个点被选择了，那么在树上和它相邻的点都不能被选择。求选出的点的权值和最大是多少？ 输入格式 第一行包含一个整数 n 。 接下来的一行包含 n 个正整数，第 i 个正整数代表点 i 的权值。 接下来一共 n-1 行，每行描述树上的一条边。 输出格式 输出一个整数，代表选出的点的权值和的最大值。 样例输入 51 2 3 4 51 21 32 42 5 样例输出 12 样例说明 选择3、4、5号点，权值和为 3+4+5 = 12 。 数据规模与约定 对于20%的数据， n &lt;= 20。 对于50%的数据， n &lt;= 1000。 对于100%的数据， n &lt;= 100000。 权值均为不超过1000的正整数。 分析 这是一道树形动态规划题目，需要用dfs遍历树，再通过动态规划求解。 建立dp[] [],dp[i] [0]表示i结点不选时的最大权值，dp[i] [1]表示i结点选择时的最大权值 状态转移方程： dp[i] [1]=dp[i] [1]+dp[j] [0] (j为i的子节点,因为i已经选了，所以j不能选) dp[i] [0]=dp[i] [0]+max{dp[j] [0],dp[j] [1]}(i结点不选, 则比较j结点选和不选哪个权值比较大) 最后题目解为max{dp[1] [0],dp[1] [1]} (选择1结点或不选择1结点) 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950import java.util.Scanner;public class 结点选择_动态规划_树形结构 { static int n; static int dp[][],list[][]; public static void main(String[] args) {//超时 但代码应该正确 Scanner in=new Scanner(System.in); n=in.nextInt(); dp=new int [100001][2]; //0表示不要这点权值，1表示要 list=new int [100001][300]; for(int i=1;i&lt;=n;i++){ dp[i][1]=in.nextInt(); } for(int j=1;j&lt;n;j++){ Add(in.nextInt(),in.nextInt()); } dp(1,0); System.out.println(max(dp[1][0],dp[1][1])); } static void Add(int a,int b){//建立树，注意一个点两条边都要标记 int i=0,j=0; while(true){ if(list[a][i]!=0) i++; else{ list[a][i]=b;break; } } while(true){ if(list[b][j]!=0) j++; else{ list[b][j]=a;break; } } } static void dp(int son,int father){//遍历树 int son1; for(int i=0;list[son][i]!=0;i++){ son1=list[son][i]; if(son1!=father){//如果不是和父结点形成的边，进入下一层 dp(son1,son); dp[son][1]+=dp[son1][0]; dp[son][0]+=max(dp[son1][0],dp[son1][1]); } } return ; } static int max(int x,int y){ if(x&gt;y) return x; else return y; }} 5.K好数问题描述 如果一个自然数N的K进制表示中任意的相邻的两位都不是相邻的数字，那么我们就说这个数是K好数。求L位K进制数中K好数的数目。例如K = 4，L = 2的时候，所有K好数为11、13、20、22、30、31、33 共7个。由于这个数目很大，请你输出它对1000000007取模后的值。 输入格式 输入包含两个正整数，K和L。 输出格式 输出一个整数，表示答案对1000000007取模后的值。 样例输入 4 2 样例输出 7 数据规模与约定 对于30%的数据，KL &lt;= 106； 对于50%的数据，K &lt;= 16， L &lt;= 10； 对于100%的数据，1 &lt;= K,L &lt;= 100。 分析 K进制的大概意思是它每一位的组成只能从0-k-1中选取，如果想直接求L位长的K进制数有多少K好数，可能有些复杂。先从L=1开始求,再从L=2,L=3 以此类推，便可以通过累加得出L位长的K好数总共有多少了。 建立dp[i] [j]表示i长度，j为开头数字满足K好数的个数 比如K=3，L=1，此时的K好数分别为0、1、2.即dp[1] [0]=1,dp[1] [1]=1,dp[1] [2]=1 L=2时,此时的K好数分别为oo、02,11，20、22 所以状态方程为: 12345for(int n=0;n&lt;K;n++){ if(n!=j+1&amp;&amp;n!=j-1){//即n不是j相邻的数，也就是说第二个数字为n和第一个数字为j是不相邻的 dp[L][j]+=dp[L-1][n];//那么第L行第一个数字为j获得了第L-1行第一个数字为n的所有K好数 }} 代码123456789101112131415161718192021222324252627import java.util.Scanner;public class K好数_动态规划 { static int K,L; static long dp[][]; static long mod=1000000007,sum; public static void main(String[] args) { Scanner in=new Scanner(System.in); K=in.nextInt(); L=in.nextInt(); dp=new long [L][K]; for(int q=0;q&lt;K;q++) dp[0][q]=1; for(int i=1;i&lt;L;i++) for(int j=0;j&lt;K;j++)//dp[i][j]表示第i位 第一位是数字j的k好数 for(int x=0;x&lt;K;x++){ if(x!=j-1&amp;&amp;x!=j+1){ dp[i][j]+=dp[i-1][x]; dp[i][j]%=mod; } } for(int y=1;y&lt;K;y++){ sum+=dp[L-1][y]; sum%=mod; } System.out.println(sum); }} 6.被3整除的子序列题目描述 给你一个长度为50的数字串,问你有多少个子序列构成的数字可以被3整除 答案对1e9+7取模 输入描述: 1输入一个字符串，由数字构成，长度小于等于50 输出描述: 1输出一个整数 示例1 输入 1132 输出 13 分析一个数的位数相加如果能被3整除的话，这个数就能被三整除，长度最大为50所以和数最大为50*9=450。dp[i] [j]表示前i位能组成和数为j的个数。状态转移方程： 1234567for(int i=1;i&lt;=len;i++) for(int j=0;j&lt;500;j++){ dp[i][j]=dp[i-1][j];//继承上一个区间组成j的个数 if(j==f(ar[i-1])) dp[i][j]++;//等于此区间组成和数j的方法加一 if(j&gt;=f(ar[i-1])) dp[i][j]+=dp[i-1][j-f(ar[i-1])];//如果大于等于那么组成和数j的方法为上一个区间[j-ar[i-1]]的个数，因为j已经大于ar[i-1]了，用x=j-ar[i-1]表示组成j还差多少，那么上一个区间组成x的个数也要加上。 dp[i][j]%=mod; } 代码12345678910111213141516171819202122232425262728293031323334import java.util.Scanner;public class 被三整除的整数列_动态规划 { static char ar[]=new char [55],a[]; static long dp[][]=new long[55][555]; static int len=0; static long mod=(long)(1e9+7),count=0; public static void main(String[] args) { Scanner in=new Scanner(System.in); a=in.next().toCharArray(); len=a.length; for(int x=0;x&lt;len;x++) ar[x]=a[x]; dp(); } static int f(char c){ return c-'0'; } public static void dp(){ for(int i=1;i&lt;=len;i++) for(int j=0;j&lt;500;j++){ dp[i][j]=dp[i-1][j]; if(j==f(ar[i-1])) dp[i][j]++; if(j&gt;=f(ar[i-1])) dp[i][j]+=dp[i-1][j-f(ar[i-1])]; dp[i][j]%=mod; } for(int k=0;k&lt;500;k++){ if(k%3==0) count=(count+dp[len][k])%mod; } System.out.println(count); }}","link":"/2019/05/03/%E7%AE%97%E6%B3%95-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"},{"title":"算法-回溯","text":"概述 回溯法有”通用解题法”之美称，是一种比枚举”聪明”的效率更高的搜索技术。回溯在搜索过程中动态地产生问题的解空间，系统地搜索问题的所有解。与枚举相比，回溯法的”聪明”之处在于能适时”回头”，若再往前走不可能得到解，就回溯，退一步另找线路，这样可省去大量的无效操作。因此，回溯与枚举相比，回溯更适合量比较大，候选解比较多的案例求解。 回溯法是一种试探求解的方法：通过对问题的归纳分析，找出求解问题的一个线索，沿着这一线索往前试探，若试探成功，即得到解：若试探失败，就逐步往回退，换其他路线再往前试探。因此，回溯法可以形象地概括为＂向前走，碰壁回头＂，这样可大大缩减无效操作，提高搜索效率。 相关例题 通过举例来学习和理解应该最有效的方法 1.皇后问题 在n*n的的方格棋盘上放置n个皇后，使她们互不攻击，即任意两个皇后不允许处在同一横排，同一纵列，也不允许处在同一与棋盘边框成45°角的斜线上 1.1递归回溯法123456789101112131415161718192021222324252627282930313233343536373839404142434445import java.util.Scanner;public class 皇后_回溯_递归回溯法 { //0表示此位置没有放置皇后 ，1表示已经放置 static int s,sum=0; static int []ar; //用来存放答案的 数组 static int [][]arr; //用二维数组表示棋盘 public static void main(String args[]){ Scanner in=new Scanner(System.in); s=in.nextInt(); ar=new int[s]; arr=new int [s][s]; for(int i=0;i&lt;s;i++) for(int j=0;j&lt;s;j++) arr[i][j]=0; put(0); //从第一行 开始 放置皇后 System.out.println(sum); } public static void put(int n){ //回溯函数 if(n==s){//当n=s说明所有行上 都已经成功放置皇后。 for(int k=0;k&lt;s;k++){ System.out.print(ar[k]+&quot; &quot;);//输出 一个解 } sum++; System.out.println(); return ;//返回上一层 } for(int i=0;i&lt;s;i++){ ar[n]=i; if(OkPut(n,i)) arr[n][i]=1;// 尝试在第n行第i列放置皇后，放置成功令arr[n][i]=1 else continue; put(n+1);// 如果放置成功 进入下一行 arr[n][i]=0;// 回溯的关键， 如果在下一层找不到解，则让此位置变为0（未放置状态） } return ; } public static boolean OkPut(int n,int i){ //此函数用来判断第n行第i列能否放下皇后 for(int t=n-1;t&gt;=0;t--)//判断正上方 是否已经放置皇后 if(arr[t][i]==1) return false; for(int w=n-1,s=i-1;w&gt;=0&amp;&amp;s&gt;=0;w--,s--) //判断左上方是否放置皇后 if(arr[w][s]==1) return false; for(int z=n-1,x=i+1;z&gt;=0&amp;&amp;x&lt;s;z--,x++) // 判断右上方是否放置皇后 if(arr[z][x]==1) return false; return true; }} 1.2迭代回溯法12345678910111213141516171819202122232425262728293031323334353637383940import java.util.Scanner;public class 皇后问题_回溯_迭代回溯法 { static int ar[];//存放解 static int sum=0,n;//解的个数 和规模 static Scanner in; static boolean b; public static void main(String args[]){ in=new Scanner(System.in); n=in.nextInt(); ar=new int[n]; hui(); System.out.println(sum); } public void hui(){//迭代回溯法 int i=0; ar[i]=0;//初值，相当于棋盘的(0,0)位置 while(true){ b=true;//b=true 代表当前位置能放下皇后,false表示不能 for(int h=i-1;h&gt;=0;h--)//此循环是判断能否放下皇后 if(ar[i]==ar[h]||Math.abs(ar[i]-ar[h])==i-h) b=false; //ar[i]==ar[h]判断上方是否存在皇后, Math.abs(ar[i]-ar[h])==i-h判断左上角和右上角是否存在皇后。 ps：abs(doubls n) 取绝对值 if(b&amp;&amp;i==n-1){//到达最后一层且 当前位置能放下皇后，输出一个解 sum++; for(int k=0;k&lt;n;k++){ System.out.print(ar[k]+&quot; &quot;); } System.out.println(); } if(i&lt;n-1&amp;&amp;b){//没到最后一层，且能放下皇后，进入下一层相当于递归回溯的put(n+1) i++; ar[i]=0; continue; } while(ar[i]==n-1&amp;&amp;i&gt;0){//当前层已达到规模还未找到解且不是第一层，进行回溯 i--;//进入下一层 } if(ar[i]==n-1&amp;&amp;i==0) break;//如果第一层已到达规模，说明所有解已经尝试完，结束循环 else ar[i]+=1;//否则当前层数尝试下一个解 } }} 2.桥本分数式 将1，2，3，…，9这九个数字填入下式的9个方格中（数字不能重复），使下面的分数等式成立： ​ 口/口口+口/口口=口/口口 2.1递归回溯法1234567891011121314151617181920212223242526272829303132333435363738public class 桥本分数式_递归回溯法 { static int [] ar;//存放解的数组 public static void main(String args[]) { ar=new int [9]; put(0); } public static void put(int n){//回溯函数 if(n==9){//当n=9说明9个数字已经全部放入方块中 if(b(ar)&amp;&amp;ar[0]&lt;ar[3]) pritf(ar);//ar[0]&lt;ar[3]去掉重复解，比如1/26+5/78=4/39和5/78+1/26=4/39为同一个解 return ; } for(int i=1;i&lt;10;i++){ if(is(n,i)) ar[n]=i;//判断第n+1个方块能否放下数字i else continue; put(n+1);//进入下一层 } return ; } public static boolean is(int n,int i){ for(int j=0;j&lt;n;j++){ if(ar[j]==i) return false; } return true; } public static boolean b(int []a){//判断是否满足口/口口+口/口口=口/口口这个式子 int a1=a[0]*(a[7]*10+a[8])*(a[4]*10+a[5]); int a2=a[3]*(a[1]*10+a[2])*(a[7]*10+a[8]); int a3=a[6]*(a[1]*10+a[2])*(a[4]*10+a[5]); if(a1+a2==a3) return true; return false; } public static void pritf(int []a){//打印函数 for(int k=0;k&lt;9;k++){ System.out.print(a[k]+&quot; &quot;); } System.out.println(); }} 2.2迭代回溯法12345678910111213141516171819202122232425262728293031323334353637383940414243public class 桥本分数式_迭代回溯法 { static int ar[],i,sum=0; static boolean b; public static void main(String args[]){ ar=new int [9]; hui(); System.out.println(sum); } public void hui(){//回溯函数 i=0;ar[i]=1; while(true){ b=true; for(int k=i-1;k&gt;=0;k--){ if(ar[k]==ar[i]) {b=false; break;}//判断前面是否有相同的数 } if(i==8&amp;&amp;b&amp;&amp;ar[0]&lt;ar[3]&amp;&amp;b(ar)){//到达最后一层且数字与前面无重复且ar[0]&lt;ar[3]（除去重复解）且满足题目约束条件 pritf(ar);//输出解 sum++;//解+1 } if(i&lt;8&amp;&amp;b){//进入下一层 i++; ar[i]=1; continue; } while(ar[i]==9&amp;&amp;i&gt;0) i--;//当其中一层的值到达9，回溯 if(ar[i]==9&amp;&amp;i==0) break;//第一层的值到达9，结束 else ar[i]++; } } public static boolean b(int []a){//判断函数 int a1=a[0]*(a[7]*10+a[8])*(a[4]*10+a[5]); int a2=a[3]*(a[1]*10+a[2])*(a[7]*10+a[8]); int a3=a[6]*(a[1]*10+a[2])*(a[4]*10+a[5]); if(a1+a2==a3) return true; return false; } public static void pritf(int []a){//打印函数 for(int k=0;k&lt;9;k++){ System.out.print(a[k]+&quot; &quot;); } System.out.println(); }} 总结1.递归回溯法 递归设计思路容易，但效率较低。基本上是由一个函数实现，当满足条件则进入下一层。当层数达到条件时，进入判断，满足则找到一个解。 关键点在于通过不断调用函数put(int n)进入下一层 基本框架为： 12345678910111213141516int ar[];//用来存放解void put(int n){ if(n==（规模）){//每一层都找到了合适解 if(（约束条件）){ printf(（输出一个解）); } return ;//返回上一层 } for(int k=0;k&lt;(规模);k++){ if(（约束条件）){//满足约束条件。则找到这一层的解 ar[n]=k;//赋值 }else continue;//不满足 则尝试下一个值 put(n+1);//进入下一层 } return ;//这一层没有找到合适的解，返回下一层} 2.迭代回溯法 相对于递归回溯法来说，迭代回溯法设计思路较为复杂，但效率比递归回溯法高。ps:两个算法的设计模式没有多大的区别，彻底理解递归回溯后，迭代回溯应该没什么问题。 基本框架： 12345678910111213141516int i=1 ,ar[i]=（元素最初值）;boolean b;while(true){ b=true; for(k=i-1;k&gt;=1;k--) if(（约束条件1）) b=false;//不合适 ，将b切换为false if(b&amp;&amp;i==（规模）&amp;&amp;（约束条件2）) pritf(一个解); if(b&amp;&amp;i&lt;（规模）){ i++; ar[i]=（元素最初值）; continue; } while(a[i]==（回溯点）&amp;&amp;i&gt;1) i--; if(ar[i]==（规模）&amp;&amp;i==1) break; else a[i]+=1;} 3.自己的想法 写到这里应该差不多了，如果能看懂这两个例题应该能基本掌握回溯的思想了(当然，想要真正掌握这些知识是完全不够的)。ps：其实是自己不想写了，累了！","link":"/2019/04/16/%E7%AE%97%E6%B3%95-%E5%9B%9E%E6%BA%AF/"},{"title":"算法-递归","text":"概述 递归是一个过程或函数在定义中直接或间接调用自身的一种方法。递归算法设计，就是把一个大型的问题层层转化为一个与原问题相似的规模较小的问题，在逐步求解小问题后，再返回（回溯）得到原大型问题的解。 一般来说，递归需要有边界条件，递归前进段和递归返回段。当边界条件不满足时，递归前进：当边界条件满足时，递归返回。 如一下代码： 1234int f(int n){ if(n==1) return 1; return n*sum(n-1);} 上面的代码是求n！，输入4，则执行 4^f(3)- &gt;4^3^f(2)- &gt; 4^3^2^f(1)- &gt;4^3^2^1 递归算法一般用于解决三类问题： 数据的定义是按递归定义的 问题解法按递归算法实现。 这类问题虽则本身没有明显的递归结构，但用递归求解比迭代求解更简单 数据的结构形式是按递归定义的。 如二叉树、广义表等，由于结构本身固有的递归特性，则它们的操作可递归地描述。 缺点 递归算法解题相对常用的算法如普通循环等，运行效率较低。因此，应该尽量避免使用递归，除非没有更好的算法或者某种特定情况，递归更为适合的时候。 相关题目1.FJ的字符串问题描述： FJ在沙盘上写了这样一些字符串： A1 = “A” A2 = “ABA” A3 = “ABACABA” A4 = “ABACABADABACABA” … … 你能找出其中的规律并写所有的数列AN吗？ 输入格式 仅有一个数：N ≤ 26。 输出格式 请输出相应的字符串AN，以一个换行符结束。输出中不得含有多余的空格或换行、回车符。 样例输入 3 样例输出 ABACABA 分析一道很简单的递归题目，很明显这是二叉树的中序遍历，用递归进行二叉树的中序遍历即可 12345678910public static void f(int n){ if(n==0){ System.out.print('A'); }else { f(n-1); System.out.print((char)('A'+n)); f(n-1); } } 2.排队购票问题 一场电影开始前，售票工作正在紧张进行中。每张电影票为50元，现在有i个人排队等待购票，其中有m个人手持50元的钞票，另外n个人手持100元的钞票。假设开始售票时售票处没有零钱，求出这i个人排队购票，使售票处不至出现找不开钱的局面的不同排队种数（拿同样面值钞票的人对换位置为同一种排队） 分析 令recuision(int m,int n)表示有m个人拿的是50元钞票，n个人拿的是100元钞票，那么有一下三种情况： n=0 意味着购买票的全是拿50元的，那么这i个人的排队总数为1 ,即recuision(m,0)=1; m&lt;n 排队买票的人数里拿50元的小于拿100元的 ，这时不管怎么排队都会出现找不开钱的局面，即recuision(m,n)=0 其他 在m+n个排队购票，第m+n个人站在第m+n-1个人的后面，则第m+n个人的排队方式可由下列两种方式获得 第m+n个人拿的是100元钞票，则在他前面的m+n-1个人中，有m个拿的是50元钞票，有n-1个人拿的是100元钞票，这种情况有ecursion(m,n-1) 第m+n个人拿的是50元钞票，则在他前面的m+n-1个人中，有m-1个拿的是50元钞票，有n个人拿的是100元钞票，这种情况有ecursion(m-1,n) 那么可以获得递推关系:recursion(m+n)=recursion(m,n-1)+recursion(m-1,n) 边界条件为： 当n=0时 recursion(m,n)=1 当m&lt;n时 recursion(m,n)=0; 代码12345public static long recursion(int m,int n){ if(n==0) return 1; if(m&lt;n) return 0; return recursion(m,n-1)+recursion(m-1,n);} 3.幂方分解问题描述 任何一个正整数都可以用2的幂次方表示。例如： 137=27+23+20 同时约定方次用括号来表示，即ab 可表示为a（b）。 由此可知，137可表示为： 2（7）+2（3）+2（0） 进一步：7= 22+2+20 （21用2表示） 3=2+20 所以最后137可表示为： 2（2（2）+2+2（0））+2（2+2（0））+2（0） 又如： 1315=210 +28 +25 +2+1 所以1315最后可表示为： 2（2（2+2（0））+2）+2（2（2+2（0）））+2（2（2）+2（0））+2+2（0） 输入格式 输入包含一个正整数N（N&lt;=20000），为要求分解的整数。 输出格式 程序输出包含一行字符串，为符合约定的n的0，2表示（在表示中不能有空格） 分析创建一个一维数组用来存放2的幂方int ar[]{1,2,4,8,16,32,64,128,256,512,1024,2048,4096,8192,16384} 创建递归函数f(int n) n为待分解的数，递归出口： n=0 return ; n=1 System.out.print(“2(0)”); return ; n=2 System.out.print(“2”); return ; 代码123456789101112131415161718192021public static void f(int n){ int i=14; if(n==0) return ; if(n==1){ System.out.print(&quot;2(0)&quot;); return ; } if(n==2){ System.out.print(&quot;2&quot;); return ; } while(ar[i]&gt;n&amp;&amp;i&gt;=0) i--; System.out.print(&quot;2&quot;); if(i&gt;1){ System.out.print(&quot;(&quot;); f(i); System.out.print(&quot;)&quot;); } n=n-ar[i]; if(n&gt;0) System.out.print(&quot;+&quot;); f(n); } 4.瓷砖铺放问题描述 有一长度为N(1&lt;=Ｎ&lt;=10)的地板，给定两种不同瓷砖：一种长度为1，另一种长度为2，数目不限。要将这个长度为N的地板铺满，一共有多少种不同的铺法？ 例如，长度为4的地面一共有如下5种铺法： 4=1+1+1+1 4=2+1+1 4=1+2+1 4=1+1+2 4=2+2 编程用递归的方法求解上述问题。 输入格式 只有一个数N，代表地板的长度 输出格式 输出一个数，代表所有不同的瓷砖铺放方法的总数 样例输入 4 样例输出 5 分析创建递归函数f(int i) 调用函数时给i赋值0 创建count代表次数 每次通过判断i+1和i+2是否大于等于n 来调用f(i+1) f(i+2) 递归出口： i=n count++; return ; 代码123456789101112public static void f(int i){ if(i==n){ count++; return ; } if(i+1&lt;=n){ f(i+1); } if(i+2&lt;=n){ f(i+2); } return ; } 5.s01串问题描述 s01串初始为”0” 按以下方式变换 0变1，1变01 输入格式 1个整数(0~19) 输出格式 n次变换后s01串 样例输入 3 样例输出 101 分析很简单的一道题，就是让字符串不断转换，用循环可以轻松解决，不过这里我要用递归代替循环 创建递归函数f(int n) n表示需要转换的次数 ，当n&gt;0时调用转换函数f1，在调用自身f(n-1) ,递归出口： n==0 return ; 代码: 1234567891011121314151617181920212223242526272829303132333435import java.util.Scanner;public class s01串 { static StringBuilder str; static int n; public static void main(String[] args) { str=new StringBuilder().append(&quot;0&quot;); Scanner in =new Scanner(System.in); n=in.nextInt(); f(n); System.out.println(str); } public static void f(int n){ if(n==0){ return ; }else{ f1(); f(n-1); } } public static void f1(){ String s=str.toString(); str.delete(0, str.length()); for(int i=0;i&lt;s.length();i++){ str.append(to(s.charAt(i))); } } public static String to(char c){ if(c=='0'){ return &quot;1&quot;; }else if(c=='1') return &quot;01&quot;; return &quot;&quot;; }} 6.最优路径搜索​ 点数值三角形是一个二维数组：三角形由n行构成，第k行有k个点，每一个点都带有一个数值。寻找从顶点开始每一步可沿左斜或右斜向下至底的一条路径，使该路径所经过的点的数值和最小。 比如输入n为3，三角形为： 口 口 口 口 口 口 分析三角形可用一个二维数组存储arr[ ] [ ] min表示最短路径，创建递归函数f(int i,int j) 表示点arr[i] [j] 的最小值，那么从f(0,0)开始，f(0,0)由min{f(1,0),f(1,1)}确定，则得到递推式:min=f(i,j)+min{f(i+1,j),f(i+1,j+1)} 递归出口: i=n-1 return arr[i] [j] 代码1234public static int f(int i,int j){ if(i==n-1) return arr[i][j]; return arr[i][j]+Math.min(f(i+1,j), f(i+1,j+1)); } ps:这道题用递归计算的话会导致很多的重复计算，用动态规划解决的话效率会更高 总结 使用递归写出来的代码一般都是非常简洁的，但是有可能会导致很多的重复计算，从而导致运行效率变低。一些简单的问题可以考虑用递归来解决，但是较为复杂的问题，递归往往不是首选。","link":"/2019/04/17/%E7%AE%97%E6%B3%95-%E9%80%92%E5%BD%92/"},{"title":"算法-递推","text":"概述 递推法是一种应用非常广泛的常用算法之一，与递归有着非常密切的联系。 递推是利用问题本身所具有的递推关系求解问题的一种方法。递推算法的基本思想是把一个复杂的庞大的计算过程转化为简单过程的多次重复，该算法充分利用了计算机的运算速度快和不知疲倦的特点，从头开始一步步地推出问题最终的结果。使用递推算法编程，既可使程序简练，又可节省计算时间。 递推算法的首要问题是得到相邻的数据项之间的关系，即递推关系。它针对这样一类问题：问题的解决可以分为若干步骤，每个步骤都产生一个子解，每个子解都是由前面若干子解生成的。我们把这种由前面的子解得出后面的子解的规则称为递推关系。 实施递推的步骤 确定递推定量 应用递推算法解决问题，要根据问题具体实际设置递推变量。递推变量可以是简单变量，也可以是一维或多维数组。 建立递推关系 递推关系是指如何从变量的前一些值推出其下一个值或从变量的后一些值推出其上一个值的公式。 递推关系是递推的依据，是解决递推问题的关键。有些问题，其递推关系是明确的，大多数实际问题并没有现成的明确的递推关系，需根据问题的具体实际，不断尝试推理，才能确定问题的递推关系。 确定初始条件 对所确定的递推变量，要根据问题最简单情形的数据确定递推变量的初始值，这是递推的基础。 对递推过程进行控制 递推过程不能无休止地执行下去。递推过程在什么时候结束，满足什么条件结束，这是递推算法必须考虑的递推过程控制问题。 递推过程的控制通常可分为两种情形：一种是所需的递推次数是确定的值，可以计算出来；另一种是所需的递推次数无法确定。对于前一种情况，可以构建一个固定次数的循环来实现对递推过程的控制；对于后一种情况，需要进一步根据问题的具体实际归纳出用来结束递推过程的条件。 递推算法框架描述 简单顺推算法 顺推即从前往后推，从已求得的规模为1,2,3，…，i-1的一系列解，推出问题规模为i的解，直至得到规模为n的解。框架描述: 1234f(1:i-1)=&lt;初始值&gt;;for(k=i;k&lt;=n;k++) f(k)=&lt;递推关系式&gt;;System.out.println(f(n)); 简单逆推算法 逆推即从后往前推，从以求得的规模为n，n-1，…，i+1的一系列解，推出问题规模为i的解，直至得到规模为1的解。 1234f(n:i+1)=&lt;初始值&gt;;for(k=i;k&gt;=1;k--) f(k)=&lt;递推关系式&gt;;System.out.println(f(1)); 二维数组顺推算法 简单递推问题设置一维数组实现，较复杂的递推问题需设置二维或二维以上数组。 12345f(1,1:m)=&lt;初始值&gt;;for(k=2;k&lt;=m;k++) for(j=1;j&lt;=m;j++) f(k,j)=&lt;递推关系式&gt;;System.out.println(f(n,m)); 多关系分级递推算法 当递推关系包含两个或两个以上关系式时，通常应用多关系分级递推算法求解。 1234567891011f(1:i-1)=&lt;初始值&gt;;for(k=i;k&lt;=n;k++){ if(&lt;条件一&gt;) f(k)=&lt;递推关系1&gt;; . . . if(&lt;条件m&gt;) f(k)=&lt;递推关系式m&gt;;}System.out.println(f(n)); 相关例题1.摆动数列 已知递推数列：a(1)=1, a(2i)=a(i)+1, a(2i+1)=a(i)+a(i+1), i为正整数，试求该数列的第n项与前n项中哪些项最大？最大值为多少？ 分析递推式： 当i为偶数时， a(i)=a(i/2)+1 当i为奇数时， a(i)=a((i+1)/2)+a((i-1)/2) 每得一项与最大值max比较，如果a(i)&gt;max,则max=a(i). 代码12345678910111213141516171819202122232425import java.util.Scanner;public class 摆动数列_递推 { static int n,max=0; static int ar[]; public static void main(String args[]){ Scanner in=new Scanner(System.in); n=in.nextInt(); ar=new int[n+1]; ar[1]=1; f(n); System.out.println(&quot;最大项为：&quot;+max); } public static void f(int n){ for(int i=2;i&lt;=n;i++){ if(i%2==0){ ar[i]=ar[i/2]+1; if(ar[i]&gt;max) max=ar[i]; } if(i%2==1){ ar[i]=ar[(i+1)/2]+ar[(i-1)/2]; if(ar[i]&gt;max) max=ar[i]; } } }} 2.整数划分问题 正整数s（简称为和数）的划分（又称分划）是把s分成为若干个正整数（简称为零数或部分）之和，划分式中允许零数重复，且不记零数的次序。如： k=2: 1+1 ;2 k=3:1+1+1 ;1+2;3 k=4:1+1+1+1 ;1+1+2;1+3;4 分析 和数k的划分式与和数k-1的划分式存在以下递推关系： 在所有和数k-1的划分前加一个零数“1”都是和数k的划分式。 和数k-1的划分式的前两个零数作比较，如果第一个零数x1小于第2个零数x2，则把第1个零数加一后成为和数k的划分式。 设置一个三维数组ar[][][k] [j] [i] 表示和数k第j个划分式的第i个数，k从2开始，初始条件为： ar[2] [1] [1]=1,ar[2] [1] [2]=1,ar[2] [2] [1]=2 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546import java.util.Scanner;public class 整数划分_递推 { static int n,x=2,y;//x为当前划分式的数量 static int ar[][][]; public static void main(String args[]){ Scanner in=new Scanner(System.in); n=in.nextInt(); ar=new int [n+1][800][n+2]; ar[2][1][1]=1;//初始条件 ar[2][1][2]=1; ar[2][2][1]=2; f(n); printf(); } public static void f(int n){//递推函数 for(int i=3;i&lt;=n;i++){ for(int j=1;j&lt;=x;j++){//此for循环给每个划分式加一 ar[i][j][1]=1;//划分式的一个数为一 for(int t=2;t&lt;=i;t++) ar[i][j][t]=ar[i-1][j][t-1];//后面加上前一个和数的划分式 } y=x; for(int j=1;j&lt;=x;j++){ if(ar[i-1][j][1]&lt;ar[i-1][j][2]){//判断前一个和数的每个划分式的第一个零数是否小于第二个 y++;//划分式加一 ar[i][y][1]=ar[i-1][j][1]+1;//和数i的第y个划分式第一个数等于和数i-1的第i个划分式的第一个数加一 for(int t=2;t&lt;=i-1;t++) ar[i][y][t]=ar[i-1][j][t]; } } y++;ar[i][y][1]=i;//和数i的最后一个划分式，（就是自己本身） x=y; } } public static void printf(){ for(int i=1;i&lt;=x;i++){ System.out.print(ar[n][i][1]); int j=2; while(ar[n][i][j]&gt;0){ System.out.print(&quot;+&quot;+ar[n][i][j]);j++; } System.out.println(); } }} 3.水手分椰子问题 n名水手来到一个岛上，采了一堆后，因为疲劳都睡着了。一段时间后，第一个水手醒来，悄悄地将椰子等分成n份，多出m个椰子，便给了旁边的猴子，然后自己藏起一份，再将剩下的椰子重新合在一起，继续睡觉。不久，第二名水手醒来，同样将椰子等分成n份，恰好也多出m个，也给了猴子。然后自己也藏了一份，再将剩下的椰子重新合在一起。以后水手醒来，发现椰子少了许多，心照不宣，便把剩下的椰子分成n份，恰好又多出m个，给了猴子。 问：原来这堆椰子至少有多少个？ 分析 根据相邻两人所藏的椰子数相同，确定迭代方程：(n-1)×ar[i]=n×ar[i+1]+1 ar[i]为前一个水手分的每一份的个数，ar[i+1]为后一个水手分的每一份的个数.因为前一位水手要给自己留一份，剩下的(n-1)份留个下一个水手分，此时前一个水手分完之后的椰子数和后一个水手还未开始分椰子的椰子数是相同的。 如果式子:ar[i]=(n×ar[i+1]+1)×(n-1)经过n次迭代ar[i]都为整数，即找到一个解sum=n×ar[1]+m (因为经过n次迭代ar[1]为第一位水手分的椰子数) 代码123456789101112131415161718192021222324252627282930313233343536import java.util.Scanner;public class 水手分椰子 { static int n,m; static double ar[]; static double sum,k; public static void main(String args[]){ Scanner in=new Scanner(System.in); n=in.nextInt(); m=in.nextInt(); ar=new double [n+2]; k=n; f(n,m); System.out.println(&quot;椰子至少有&quot;+sum+&quot;个.&quot;); print(); } public static void f(int n,int m){ int i=n+1; ar[n+1]=k; while(i&gt;1){//当i=1表示已经经过n次迭代 i--; ar[i]=(n*ar[i+1]+m)/(n-1); if(ar[i]!=Math.floor(ar[i])){//floor(double x)函数: 取不大于x的最大整数 k++; ar[n+1]=k; i=n+1; } } sum=ar[1]*n+m; } public static void print(){ for(int i=1;i&lt;=n;i++){ double x=ar[i]*n+m; System.out.println(&quot;第&quot;+i+&quot;个水手将&quot;+x+&quot;个椰子分成&quot;+n+&quot;份,自己藏了&quot;+ar[i]+&quot;个椰子.&quot;); } }} 4.排队买票问题 一场电影开始前，售票工作正在紧张进行中。每张电影票为50元，现在有i个人排队等待购票，其中有m个人手持50元的钞票，另外n个人手持100元的钞票。假设开始售票时售票处没有零钱，求出这i个人排队购票，使售票处不至出现找不开钱的局面的不同排队种数（拿同样面值钞票的人对换位置为同一种排队） 分析 第m+n个人排队购票，第m+n个人站在第m+n-1个人的后面，则第m+n个人的排队方式可由下列两种情况获得: 第m+n个人手持100元钞票，则在他之前的m+n-1个人中有m个人手持50元的钞票，有n-1个人手持100元钞票，此时情况共有f(m,n-1)。 第m+n个人手持50元钞票，则在他之前的m+n-1个人中有m-1个人手持50元钞票，有n个人手持100元钞票，此时情况共有f(m-1,n)。 所以，递推式为:f(m,n)=f(m,n-1)+f(m-1,n) 代码1234567891011121314151617181920212223import java.util.Scanner;public class 排队购票_递推 { static long dp[][]; static int m,n; static Scanner in=new Scanner(System.in); public static void main(String args[]){ m=in.nextInt(); n=in.nextInt(); dp=new long [m+1][n+1]; dp(); System.out.println(dp[m][n]); } public static void dp(){ for(int i=1;i&lt;=m;i++) dp[i][0]=1; for(int i=1;i&lt;=n;i++) for(int j=i;j&lt;=m;j++){ dp[j][i]=dp[j-1][i]+dp[j][i-1]; //递推式 } }} 这种解法类似于动态规划。 总结 递推的话，就写到这了吧。end!","link":"/2019/04/23/%E7%AE%97%E6%B3%95-%E9%80%92%E6%8E%A8/"},{"title":"JDBC对象","text":"1.Driver 建立了ODBC数据源后，就可以在Java程序中通过JDBC-ODBC接口连接数据库了。无论是用JDBC-ODBC还是直接用JDBC，都需要用到Driver，即用Class.forName()方法来加载驱动程序。 在用JDBC之前，要在文件前导入有关SQL类，则用下面的语句。 1import java.sql.*; 如果使用的是JDBC-ODBC的方法，则应使用下面的语句。 1Class.forName(&quot;sun.jdbc.odbc.Jdbc.OdbcDriver&quot;); 如果使用的是JDBC，则应使用以下形式。 1Class.forName(&quot;jdbc.driver_class_name&quot;); 其中driver_class_name是驱动的类名。如： 12private static final String driver=&quot;com.mysql.jdbc.Driver&quot;;Class.forName(driver); 2.DriverManager 用DriverManager的**getConnection()**方法可以创建一个数据库连接对象，它的一般形式如下： 123public static Connection getConnection(String url) throws SQLExceptionpublic static Connection getConnection(String url,String user,String password) throws SQLExceptionpublic static Connection getConnection(String url，java.util.Properties info) throws SQLException 参数user是指连接数据库时使用的用户名；参数password是指连接数据库时的用户user的登录密码；参数info是作为连接参数的任意字符串标记/值对的列表，通常至少应该包括”user”和”password”属性；参数url是指连接数据库的URL。该方法返回一个连接，一般用一个连接对象接收返回对象。 如： 12345678private static final String url=&quot;jdbc:mysql://localhost:3306/demo1&quot;;private static final String user=&quot;root&quot;;private static final String password=&quot;987654zmd&quot;;try { Connection con = DriverManager.getConnection(url, user, password); } catch (SQLException e) { e.printStackTrace(); } DriverManager在JDBC规范中是类而不是接口。它是一个服务类，用于管理JDBC驱动程序，提供getConnection()方法建立应用程序与数据库的连接。当JDBC驱动程序载入到内存时，会自己主动向DriverManager注冊。此行代码发出连接请求，DriverManager类就会用注冊的JDBC驱动程序来创建到数据库的连接。 DriverManager.getConnection()是个静态方法。 DriverManager在java.sql包中。当我们调用sql包里不论什么一个类（包含接口）的不论什么一个方法时都会报一个编译时异常SQLException。这里我们使用一个try块后跟多个catch块解决。 常用的数据库软件的url写法： Oracle: jdbc:oracle:thin:@ip:1521:dbName； MySql：jdbc:mysql://ip:3306:dbName； SQLServer：jdbc:sqlserver://ip:1443;databaseName=dbName； 当使用本机ip地址连接时须要关闭防火墙。否则连接不上，使用localhost或127.0.0.1则不用关闭防火墙。 3.Connection 一个Connection对象表示与特定数据库的连接，主要用于执行SQL语句并得到执行的结果。默认情况下，Connection对象处于自动提交模式下，也就是说它在执行每个SQL语句后都会自动提交更改，如果禁用自动提交模式，为了提交更改就必须调用commit()方法，否则将无法保存数据库更改。 常量 TRANSACTION_NONE 指示事务不受支持的常量。 TRANSACTION_READ_UNCOMMITTED 指示可以发生脏读 (dirty read)、不可重复读和虚读 (phantom read) 的常量。此级别允许由某一事务更改的行在已提交该行中的所有更改之前被另一个事务读取（“脏读”）。如果所有更改都被回滚，则第二个事务将检索无效的行。 TRANSACTION_READ_COMMITTED 指示防止发生脏读的常量；不可重复读和虚读有可能发生。此级别只禁止事务读取其中带有未提交更改的行。 TRANSACTION_REPEATABLE_READ 指示防止发生脏读和不可重复读的常量；虚读有可能发生。此级别禁止事务读取其中带有未提交更改的行，它还禁止这种情况：一个事务读取某一行，而另一个事务更改该行，第一个事务重新读取该行，并在第二次读取时获得不同的值（“不可重复读”）。 TRANSACTION_SERIALIZABLE 指示防止发生脏读、不可重复读和虚读的常量。此级别包括TRANSACTION_REPEATABLE_READ中禁止的事项并进一步禁止出现这种情况：某一事务读取所有满足WHERE条件的行，另一个事务插入一个满足WHERE条件的行，第一个事务重新读取满足相同条件的行，并在第二次读取时检索到额外的“虚”行。 常用的方法 close() 此方法用来立即释放此Connection对象的数据库和JDBC资源，而不是等待它们被自动释放。在已经关闭的Connection对象调用close()方法将什么事也不做。 1void close() throws SQLException commit() 此方法使自从上一次提交以来进行的所有更改成为持久更改，并释放此Connection对象当前保存的所有数据库锁定。此方法应该只在已禁用自动提交模式时使用。 1void commit() throws SQLException createStatement() 此方法创建一个Statement对象将SQL语句发送到数据库。没有参数的SQL语句通常使用Statement对象执行。如果多次执行相同的SQL语句，使用PrepareStatement对象可能更加有效。 123Statement createStatement() throws SQLExceptionStatement createStatement(int resultSetType,int resultSetConcurrency) throws SQLExceptionStatement createStatement(int resultSetType,int resultSetConcurrency,int resultSetHoldability) throws SQLException getAutoCommit() 检索当前Connection对象的自动提交模式。如果是true表示是自动提交模式，如果是false表示禁用自动提交模式，而需要开发人员在程序中显示地使用commit()提交事务。 1boolean getAutoCommit() throws SQLException getMetaDate() 获取DatabaseMetaDate对象，该对象包含关于Connection对象连接到的数据库的元数据。元数据包括关于数据库的表、受支持的SQL语法、存储过程、此连接的功能等信息。 1DatabaseMetaDate getMetaData() throws SQLException getTransactionIsolation() 得到当前Connection对象的当前事务隔离级别。 1int getTransactionIsolation() throws SQLException isClosed() 检查当前Connection对象是否已经被关闭。如果已经连接上，在调用close()方法或者发生某些严重的错误后会关闭Connection。isClosed()方法只保证在已经调用Connection.close()方法之后被调用时返回true。 1boolean isClosed() throws SQLException isReadOnly() 判断当前Connection对象是否处于只读模式，是返回true，否则返回false。 1boolean isReadOnly() throws SQLException prepareCall() 创建一个CallableStatement对象来调用数据库存储过程。CallableStatement对象提供了设置其输入(IN)和输出(out)参数的方法，以及用来执行对存储过程的调用方法。方法返回一个包含预编译的SQL语句的新的CallableStatement对象。 123CallableStatement prepareCall(String sql) throws SQLExceptionCallableStatement prepareCall(String sql) throws SQLExceptionCallableStatement prepareCall(String sql) throws SQLException prepareStatement() 此方法创建一个PrepareStatement对象，以用这个对象来将参数化的SQL语句发送到数据库。带有输入(IN)参数或不带有输入(IN)参数的SQL语句都可以被预编译并存储在PrepareStatement对象中，然后可以使用此对象来多次执行该语句。 1PrepareStatement prepareStatement(String sql) throws SQLException prepareStatement可以对SQL语句做预编译处理，但前提是数据库驱动程序要支持预编译，prepareStatement方法会将该语句发送给数据库进行预编译。有的数据库驱动程序可能不支持预编译，此时执行PrepareStatement对象之前无法将语句发送给数据库。 rollbavk() 取消在当前事务中进行的所有更改，并释放当前Connection对象保存的所有数据库锁定。 rollback()方法只能在已禁用自动提交模式时使用。 1void rollbavk() throws SQLException setAutoCommit() 将当前连接的自动提交模式设置为给定状态。如果连接处于自动提交模式下，则将执行其所有SQL语句，并将这些语句作为单独的事务提交。否则，其SQL语句将成组地进入通过调用commit()方法或rollback()方法终止的事务中。默认情况下，新的连接处于自动提交模式下。 1void setAutoCommit(boolean autoCommit) throws SQLException autoCommit参数为true表示启用自动提交模式；为false表示禁用自动提交模式。 serHoldability() 将使用当前Connection对象创建的ResultSet对象的可保存性更改为给定的可保存性。 1void serHoldability(int holdability) throws SQLException setReadOnly() 此方法用于将当前连接设置为只读模式。 1void setReadOnly(boolean readOnly) throws SQLException setTransactionIsolation() 将当前connection对象的事务隔离级别更改为给定的级别。 1void setTransactionIsolation(int level) throws SQLException 4.Statement Statement类对象代表SQL语句，可用于将SQL语句发送至数据库。其中存在三种Statemen对象，一是Statemen，用来执行基本的SQL语句；二是PreparedStatement，它从Statement继承而来，用于提供可以与查询信息一起预编译的语句；三是CallableStatement，它继承自PreparedStatement，用来执行数据库中的存储过程。 Statement用于执行静态SQL语句并返回它所生成结果的对象。在默认情况下，同一时刻每个Statement对象只能打开一个ResultSet对象，因此如果读取一个ResultSet对象与读取另一个交叉，则这两个对象必须是由不同的Statement对象生成的。如果存在某个语句打开的当前ResultSet对象，则Statement接口中的所有执行方法都会隐式关闭它。 常量 CLOSE_CURRENT_RESULT 该常量指示调用 getMoreResults 时应该关闭当前 ResultSet 对象。 KEEP_CURRENT_RESULT 该常量指示调用 getMoreResults时应该关闭当前 ResultSet对象。 CLOSE_ALL_RESULTS 该常量指示调用 getMoreResults时应该关闭以前一直打开的所有 ResultSet对象。 SUCCESS_NO_INFO 该常量指示批量语句执行成功但不存在受影响的可用行数计数。 EXECUTE_FAILED 该常量指示在执行批量语句时发生错误。 RETURN_GENERATED_KEYS 该常量指示生成的键应该可用于检索。 NO_GENERATED_KEYS 该常量指示生成的键应该不可用于检索。 常用方法 addBatch() addBatch()方法用于将给定的SQL命令添加到此Statement对象的当前命令列表中，此后通过调用executeBatch()方法可以批量执行此列表的命令。参数sql通常为静态的SQL insert或update语句。 1void addBatch(String sql) throws SQLException cancel() 如果数据库管理系统和数据库驱动程序都支持终止SQL语句，则取消此Statement对象。一个线程可以使用此方法取消另一个线程正在执行的语句。 1void cancel() throws SQLException clearBatch() 清空此Statement对象的当前SQL命令列表。 1void clearBatch() throws SQLException close() 立即释放当前Statement对象的数据库和JDBC资源而不是等待该对象自动关闭时发生此操作。在使用完Statement对象后立即释放资源是一个好的习惯，这样可以避免对数据库资源的占用。 1void close() throws SQLException execute() 执行给定的SQL语句，该语句可能返回多个结果。execute()方法指示第一个结果的形式。如果第一个为ResultSet对象，则返回true；如果其为更新计数或者不存在任何结果，则返回false。执行SQL语句后，必须使用方法getResultSet()或getUpdateCount()来检索结果，使用getMoreResults()来移动后续成果。 1boolean execute(String sql) throws SQLException executeBatch() 将一批命令提交给数据库来执行，如果全部命令执行成功，则返回更新计数组成的数组。返回数组的int元素的排序对应批中的命令。 1int[] executeBatch() throws SQLException executeQuery() 执行给定的SQL语句，该语句返回单个ResultSet对象。参数sql是要发送给数据库的SQL语句。通常为静态SQL select语句。 1ResultSet executeQuery(String sql) throws SQLException executeUpdate() 执行给定SQL语句，该语句可能为insert、update、delete语句，或者不返回任何内容的SQL语句。该函数返回SQL语句所影响的行数，如果是不返回任何内容的SQL语句或没有影响的行数则返回0； 1int executeUpdate(String sql) throws SQLException getConnection() 得到当前Statement对象的Connection对象。 1Connection getConnection() throws SQLException getMaxFieldSize() 获得可以为当前Statement对象所生成ResultSet对象中的字符和二进制列值返回的最大字节数。 1int getMaxFieldSize() throws SQLException getMaxRows() 获得当前Statement对象生成的ResultSet对象可以包含的最大行数。 1int getMaxRows() throws SQLException getMordResults() 移动到当前Statement对象的下一个结果，如果这个结果为ResultSet对象，则返回true，并隐式关闭利用getResultSet()方法获取的所有当前ResultSet对象。 1boolean getMordResults() throws SQLException getSesultSet() 得到当前Statement对象执行SQL的结果ResultSet，如果结果是更新计数或没有更多的结果则返回null。 1ResultSet getSesultSet() throws SQLException getUpdateCount() 得到当前Statement对象执行SQL结果，结果以更新计数的形式返回；如果当前结果为ResultSet对象或没有更多结果，则返回-1。 1int getUpdateCount() throws SQLException isClosed() 验证当前Statement对象是否已经被关闭，如果已经被关闭则返回true，否则返回false。 1boolean isClosed() throws SQLException setMaxFieldSize() 设置将字符或二进制存储到给定ResultSet列中的最大字节数限制。 1void setMaxFieldSize(int max) throws SQLException setMaxRows() 设置通过当前Statement对象所能获得的任何ResultSet对象都可以包含的最大行数限制，如果超过了该限制，则会撤销多出的行。 1void setMaxRows(int max) throws SQLException 5.PreparedStatement PreparedStatement用于表示预编译SQL语句的对象。SQL语句被预编译并且存储在PreparedStatement对象中，然后可以使用此对象高效地多次执行语句。 PreparedStatement是预编译的，使用PreparedStatement有几个好处 ： 在执行可变参数的一条SQL时，PreparedStatement比Statement的效率高，因为DBMS预编译一条SQL当然会比多次编译一条SQL的效率要高。 安全性好，有效防止Sql注入等问题。 对于多次重复执行的语句，使用PreparedStament效率会更高一点，并且在这种情况下也比较适合使用batch 代码的可读性和可维护性。 PreparedStatement接口声明如下： 1public interface PreparedStatement extends Statement; 可见PreparedStatement接口扩展了Statement接口，下面列出不是继承自Statement接口的一个常用方法： 1void setXxxx(int parameterIndex,Xxxx x) throws SQLException; 将SQL语句中给定的第parameterIndex个参数设为x，Xxxx表示数据类型，于是有如下常用的表示形式： 1234567891011void setboolean(int parameterIndex,boolean x) throws SQLException;void setByte(int parameterIndex,Byte x) throws SQLException;void setBytes(int parameterIndex,Byte x[]) throws SQLException;void setDate(int parameterIndex,java.sql.Date x) throws SQLException;void setDouble(int parameterIndex,Double x) throws SQLException;void setfloat(int parameterIndex,float x) throws SQLException;void setInt(int parameterIndex,int x) throws SQLException;void setLong(int parameterIndex,long x) throws SQLException;void setObject(int parameterIndex,Object x) throws SQLException;void setShort(int parameterIndex,Short x) throws SQLException;void setString(int parameterIndex,String x) throws SQLException; parameterIndex参数表示第几个参数，编号从1开始，也就是第一个参数的parameterIndex为1，第二个参数的parameterIndex为2。 比如给用户表添加一个用户： 123456789101112131415161718192021222324252627282930313233public boolean AddUser(Reader r){//添加用户 Reader为用户实体类 String sql = &quot;insert into reader (Rname,Rpassword,phone,Rsex,type) value (?,?,?,?,?)&quot;; boolean bo=false; Object []objects={r.getRname(),r.getRpassword(),r.getphone(),r.getRsex(),r.gettype()}; bo=sqlUpdate(sql, objects); return bo; }public boolean sqlUpdate(String sql, Object[] objects) { boolean b = false; con = getUtilsConnection(); try { pstmt = con.prepareStatement(sql);//预编译SQL语句 if (objects != null) { for (int i = 0; i &lt; objects.length; i++) { pstmt.setObject(i + 1, objects[i]);//设置参数，就是上面SQL的问号 } } int row = 0; row = pstmt.executeUpdate(); if (row &gt; 0) { b = true; } } catch (SQLException e) { e.printStackTrace(); }finally { close(con, pstmt, null); } return b; } 6.CallableStatement CallableStatement是用于执行SQL存储过程的接口。JDBC API提供了一个存储过程SQL转义语法，该语法允许对所有数据库管理系统使用标准方式调用存储过程，此转义语法有一个包含结果参数的形式和一个不包含结果参数的形式。它支持调用存储过程,提供了对输出和输入/输出参数(INOUT)的支持。 12{?= call &lt;procedure-name&gt;[&lt;arg1&gt;,&lt;arg2&gt;,...]}{call &lt;procedure-name&gt;[&lt;arg1&gt;,&lt;arg2&gt;,...]} 存储过程的输入参数值是使用从PreparedStatement中继承的set方法设置的，在执行存储过程之前，必须注册所有输出参数的类型；它们的值是在执行后通过此类提供的get方法获得的。注册输出参数使用registerOutParameter()方法，有如下的几种形式。 12void registerOutParameter(int parameterIndex,int sqlType) throws SQLExceptionvoid registerOutParameter(int parameterIndex,int sqlType,int scale) throws SQLException 以上方法的功能是按顺序位置parameterIndex将输出参数注册为JDBC类型sqlType。由sqlType指定的输出参数的JDBC类型确定必须用getXxxx()方法来读取该参数值的java类型。如果预期返回给此输出参数的JDBC类型是取决于此特定数据库的，则sqlType应该是java.sql.Type,OTHER。方法getobject(int)检索该值。 要得到存储过程的返回结果集一般使用PreparedStatement类的excuteQuery()方法，而不必去注册输出参数，excuteQuery()方法也是最为常用的得到输出参数值的方法。 CallableStatement可以返回一个ResultSet对象或多个ResultSet对象。多个ResultSet对象是使用从Statement中继承的操作处理的。 为了获得良好的可移植性，某一调用的ResultSet对象和更新计数应该在获得输出参数的值之前处理。 7.ResultSet ResultSet表示数据库结果记录集的数据表，通常通过执行查询数据库的语句生成。ResultSet对象具有指向其当前数据行的指针。最初指针被置于第一行之前，next()方法将指针移动到下一行；因为该方法在ResultSet对象中没有下一行时返回false，所以可以在while循环中使用它来迭代结果记录集。 默认情况下，ResultSet对象不可更新，且仅有一个向前移动的指针，因此只能迭代它一次，并且只能按从第一行到最后一行的顺序进行。可以生成可滚动或可更新的ResultSet对象。以下代码片段演示了如何生成可滚动且不受其他更新影响的、可更新的结果记录集。 12Statement stmt=con.createStatement(ResultSet.TYPE_SCROLL_INSENSITIVE,ResultSet.CONCUR_UPDATABKE);ResultSet rs =stmt.executeQuery(&quot;SELECT 字段名1,字段名2, FROM 表名&quot;); 更新当前行中的列值 在可滚动的ResultSet对象中，可以向前和向后移动指针，将其置于绝对位置或相对于当前行的位置，以下代码片段更新ResultSet对象rs的第五行中的NAME列，然后使用方法updateRow()更新用于生成结果记录集rs的数据源表。 123rs.absolute(5);//将指针移动到结果记录集rs的第五条rs.updateString(&quot;NAME&quot;,&quot;zhai&quot;);//将第五条记录的NAME值改为zhairs.updateRow();//更新数据库中的数据 将列值插入到插入行中 可更新的ResultSet对象具有一个与其关联的特殊行，该行用作构建要插入的行的暂存区域。以下代码片段将指针移动到插入行，构建一个3列的行，并使用insertRow()方法将其插入到结果记录集rs和数据源表中。 123456rs.moveToInsertRow()；//移动当前记录指针标到insert rowrs.updateString(1,&quot;zhai&quot;);//将insert row中第一列的值更新为zhairs.updateInt(2,21);//将insert row中第二列的值更新为35rs.updateBoolean(3,true);//将insert row中第三列的值更新为truers.insertRow();//更新数据rs.moveToCurrentRow(); insert row是结果记录集中的一个特殊的记录，它实质上是构造的一个数据缓冲区。 常量 FETCH_FORWARD 该常量指示将按正向（即从第一个到最后一个）处理结果集中的行。setFetchDirection方法将此常量用作驱动程序的提示，驱动程序可能忽略它。 FETCH_REVERSE 该常量指示将按反向（即从最后一个到第一个）处理结果集中的行处理。setFetchDirection方法将此常量用作驱动程序的提示，驱动程序可能忽略它。 FETCH_UNKNOWN 该常量指示结果集中的行的处理顺序未知。setFetchDirection方法将此常量用作驱动程序的提示，驱动程序可能忽略它。 TYPE_FORWARD_ONLY 该常量指示指针只能向前移动的 ResultSet对象的类型。 TYPE_SCROLL_INSENSITIVE 该常量指示可滚动但通常不受其他的更改影响的 ResultSet对象的类型。 TYPE_SCROLL_SENSITIVE 该常量指示可滚动并且通常受其他的更改影响的 ResultSet对象的类型。 CONCUR_READ_ONLY 该常量指示不可以更新的 ResultSet对象的并发模式。 CONCUR_UPDATABLE 该常量指示可以更新的 ResultSet对象的并发模式。 HOLD_CURSORS_OVER_COMMIT 该常量指示调用 Connection.commit方法时不应关闭 ResultSet对象。 CLOSE_CURSORS_AT_COMMIT 该常量指示调用 Connection.commit方法时应该关闭 ResultSet对象。 常用方法 absolute() absolute()方法用于将指针移动到此SesultSet对象的给定行编号。如果编号为正，则将指针移动到相对于结果记录集开头的给定行编号，第一行为行1，第二行为行2，以此类推。 1boolean absolute(int row) throws SQLException 如果给定行编号为负，则将指针移动到相对于结果记录集末尾的绝对行位置。列如，absolute(-1)将指针置于最后一行；absolute(-2)将指针移动到倒数第二行，以此类推。 调用absolute(1)等效于调用first(),调用absolute(-1)等效于调用last() afterLast() 将指针移动到此ResultSet对象的末尾，正好位于最后一行之后。如果结果记录集中不包含任何行，则此方法无效。 1void afterLast() throws SQLException beforeFirst() 将指针移动到此ResultSet对象的开头，正好位于第一行之前。 1void beforeFirst() throws SQLException cancelRowUpdates() 取消对ResultSet对象中的当前行所作的更新。此方法在调用更新方法之后，但在调用updateRow()之前调用才可以后滚对行所作的更新。 1void cancelRowUpdates() throws SQLException close() 立即释放此ResultSet对象的数据库和JDBC资源。 1void close() throws SQLException deleteRow() 从当前ResultSet对象和底层数据库删除当前行。指针不位于插入行时不能调用此方法。 1void deleteRow() throws SQLException first() 将指针移动到当前ResulSet对象的第一行。 1boolean first() throws SQLException getXxxx(int columnIndex) 此方法以Java中的数据类型来得到ResultSet对象中当前行的第columnIndex列的值，第一个列的columnIndex为1，第二个列的columnIndex为2，以此类推 1xxxx getXxxx(int columnIndex) throws SQLException getXxxx(String columnName) 此方法以Java中的数据类型来得到ResultSet对象中当前行的列名为columnName列的值。 1xxxx getXxxx(String columnName) throws SQLException getConcurrency() 得到当前ResultSet对象的并发模式，值为ResultSet.CONCUR_READ_ONLY或ResultSet.CONCUR_UPDATABLE。 1int getConcurrency() throws SQLException getRow() 得到当前行的编号。第一行为1号，第二行为2号，以此类推。 1int getRow() throws SQLException getType() 得到当前ResultSet对象的类型，返回值为Result.TYPE_FORWARD_ONLY、ResultSet.TYPE_SCROLL_INSENSITIVE或ResultSet.TYPE_SCROLL_SENSITIVE中的一个。 1int getType() throws SQLException insertRow() 将插入行的内容插入到当前ResultSet对象和数据库中，此时当前指针必须位于插入行上。如果发生数据库访问错误，或者当前指针不位于插入行上时调用此方法，或者插入行中所有不可为null的列中还存在未分配值的列，则会抛出SQLException异常。 1void insertRow() throws SQLException isAfterLast() 判断当前指针是否位于ResultSet对象的最后一行之后，是则返回true，否则返回false。 1boolean isAfterLast() throws SQLException isBeforeFirst() 判断当前指针是否位于ResultSet对象的第一行之前，是则返回true，否则返回false。 1boolean isBeforeFirst() throws SQLException isFirst() 判断当前指针是否位于ResultSet对象的第一行，是则返回true，否则返回false。 1boolean isFirst() throws SQLException isLast() 判断当前指针是否位于ResultSet对象的最后一行，是则返回true，否则返回false。 1boolean isLast() throws SQLException last() 将指针移动到当前ResultSet对象的最后一行。 1boolean last() throws SQLException moveToInsertRow() 将指针移动到插入行。将指针置于插入行时，当前的指针位置会被记住。插入行是一个与可更新结果集相关联的特殊行。它实际上是一个缓冲区，在将行插入到结果集前可以通过调用更新方法在其中构造新行。当指针位于插入行上时，仅能调用更新方法、获取方法以及insertRow()方法。每次在调用insertRow()之前调用此方法时，必须为结果集中的所有列分配值。在对列值调用获取方法之前，必须调用更新方法。如果发生数据库访问错误或者结果集不可更新将会抛出SQLException异常。 1void moveToInsertRow() throws SQLException next() 将指针从当前位置下移一行。 1boolean next() throws SQLException relative() 将当前指针移动到ResultSet对象的上一行。 1boolean relative() throws SQLException relative() 按相对行数(或正或负)移动指针。参数row指定从当前行开始移动的行数，正数表示指针向前移动，负数表示指针向后移动。调用relative(0)有效，但是不更改指针位置。 updateXxxx(int columnIndex,xxxx x) 用指定的Java数据类型更新当前行的第columnIndex列的值。 1void updateXxxx(int columnIndex,xxxx x) throws SQLException updateXxxx(String columnName,xxxx x) 用指定的Java数据类型更新当前列columnName的值。 1void updateXxxx(String columnName,xxxx x) throws SQLException 调用此方法并不会更新底层数据库；更新数据库要调用updateRow()或inserRow()方法。 updateRow() 将ResultSet对象的当前行的新内容更新底层数据库。指针不位于插入行上时不能调用此方法。 1void updateRow() throws SQLException","link":"/2019/05/07/JDBC%E5%AF%B9%E8%B1%A1/"},{"title":"JSP内置对象","text":"JSP内置对象包括request、response、session、application、out、config、pageContext。这些对象在服务器端和客户端交互的过程中分别完成不同的功能。Request、response、session是JSP内置对象中重要的三个对象，这三个对象提供了服务器端与客户端(即浏览器)进行交互通信的控制，它们的控制如图： 客户端的浏览器从Web服务器上获得网页实际上是使用HTTP协议，向服务器发送一个请求，服务器在收到来自客户端浏览器发来的请求后响应该请求，JSP通过request对象控制客户浏览器的请求，通过response对客户浏览器进行响应而session就保存这个会话期间需要使用的数据信息。请求的方法有许多种，有post、get、put、head、delete、trace等，最常用的是前两种。request和respone对象还可以操作HTTP头中的数据。 1.request对象 request对象封装了客户端提交的数据信息，包括用户提交的信息以及客户端的一些信息。客户端可通过HTML表单或者在网页地址后面使用参数的方法提交数据，在用request对象的相关方法来获取提交的各种数据。 request对象所属的类实现了javax.servlet.http.HttpServletRequest 接口，此接口位于servlet-api.jar包中。 常用方法 getAttribute() 此方法将参数name指定的属性值作为一个Object 对象返回；如果参数name中给定的名字不存在相应的属性则返回null。 1public Object getAttribute(String name) getAttributeNames() 此方法得到一个Enumeration(枚举型)对象，其中的值为此请求中可用的属性的名称。 1public java.util.Enumeration getAttributeNames() getCharacterEncoding() 此方法返回请求中所用的字符编码的名称，如果未指定字符编码则返回null。 1public String getCharacterEncoding() getContentType() 此方法返回请求的MIME类型，如果类型未知返回null。 1public String getContentType() getContentPath() 此方法得到请求URI中请求的应用上下文路径。 1public String getContentPath() getLocalAddr() 此方法返回接收请求的Web服务器的地址。 1public String getLocalAddr() getLocalName() 此方法返回接收请求的Web服务器的机器名。 1public String getLocalName() getMethod() 此方法得到请求所用的HTTP请求类型，如GET、POST、PUT等。 1public String getMethod() getParameter() 此方法得到请求URI中请求的应用上下文路径。 1public String getParameter(String name) getParameterMap() 此方法得到请求中所有参数的一个Map对象，其中参数名为键，字符串数组作为值。 1public java.util.Map getParameterMap() getParameterName() 此方法获得所有请求中参数名称的枚举。 1public java.util.Enumeration getParameterName() getParameterValues() 此方法得到请求参数值的数组，数组内容为请求中指定参数name的多个值。如果在请求中找不到name参数则返回null。 1public String [] getParameterValues(String name) getProtocol() 此方法返回请求所用协议的名称和版本，其形式为:协议名称/主版本号.副版本号，如HTTP/1.1。 1public String getProtocol() getQueryString() 此方法返回请求URI中所包含的位于路径之后的查询字符串。 1public String getQueryString() getRemoteAddr() 此方法返回发送请求的客户端IP地址。 1public String getRemoteAddr() getRemoteHost() 此方法得到发送请求的客户端机器名，如果无法获得机器名则返回IP地址。 1public String getRemoteHost() getRemotePort() 此方法获得客户端或发送请求的最后一个代理的端口号。 1public String getRemotePort() getRequestURI() 此方法返回请求路径URI。 1public String getRequestURI() getRequestURI() 此方法得到请求URL，包括协议、服务器名、端口号和URL路径。 1public StringBuffer getRequestURI() getServerPort() 此方法得到接收请求的服务器端的端口号。 1public int getServerPort() getServletPath() 此方法获得当前请求URI中标识Server的部分，如果是JSP页面则是JSP页面的完整上下文路径。 1public String getServletPath() getSession() 此方法得到与当前请求相关联的HttpSession对象，如果此请求还没有会话则创建一个新的HttpSession对象并返回这个对象。 1public HttpSession getSession() removeAttribute() 此方法从请求中删除指定名称name的属性。 1public void removeAttribute(String name) setAttribute() 此方法将指定的属性对象attribute用名称name保存于请求中。 1public Object setAttribute(String name,Object attribute) setCharacterEncoding() 此方法设置读取请求数据时所使用的字符编码，此方法必须调用request的所有其他方法之前调用，其后才能再行读取参数。 1public void setCharacterEncoding(String encoding) getContentLength() 此方法获取请求信息的总长度。 1public int getContentLength() getServerName() 获取服务器名称。 1public String getServerName() getHeader() 返回参数name指定的属性值。 1public String getHeader(String name) 测试应用12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758&lt;%@ page language=&quot;java&quot; import=&quot;java.util.*&quot; pageEncoding=&quot;gb2312&quot;%&gt;&lt;%String path = request.getContextPath();String basePath = request.getScheme()+&quot;://&quot;+request.getServerName()+&quot;:&quot;+request.getServerPort()+path+&quot;/&quot;;%&gt;&lt;!DOCTYPE HTML PUBLIC &quot;-//W3C//DTD HTML 4.01 Transitional//EN&quot;&gt;&lt;html&gt; &lt;head&gt; &lt;base href=&quot;&lt;%=basePath%&gt;&quot;&gt; &lt;title&gt;My JSP 'request.jsp' starting page&lt;/title&gt; &lt;meta http-equiv=&quot;pragma&quot; content=&quot;no-cache&quot;&gt; &lt;meta http-equiv=&quot;cache-control&quot; content=&quot;no-cache&quot;&gt; &lt;meta http-equiv=&quot;expires&quot; content=&quot;0&quot;&gt; &lt;meta http-equiv=&quot;keywords&quot; content=&quot;keyword1,keyword2,keyword3&quot;&gt; &lt;meta http-equiv=&quot;description&quot; content=&quot;This is my page&quot;&gt; &lt;/head&gt; &lt;body&gt; 请求信息如下:&lt;br&gt; 请求的方法是:&lt;%=request.getMethod() %&gt; &lt;br&gt; 请求的URI是:&lt;%=request.getRequestURI() %&gt; &lt;br&gt; 请求的协议是:&lt;%=request.getProtocol() %&gt; &lt;br&gt; 接受客户提交信息的页面路径是:&lt;%=request.getServletPath() %&gt; &lt;br&gt; 请求的协议是:&lt;%=request.getProtocol() %&gt; &lt;br&gt; 请求中的查询字符串是:&lt;%=request.getQueryString() %&gt; &lt;br&gt; 请求信息的总长度是:&lt;%=request.getContentLength() %&gt; &lt;br&gt; 服务器名称是:&lt;%=request.getServerName() %&gt; &lt;br&gt; 提供HTTP服务的服务器端口号是:&lt;%=request.getServerPort() %&gt; &lt;br&gt; 客户端IP是:&lt;%=request.getRemoteAddr() %&gt; &lt;br&gt; 客户端机器的名称是:&lt;%=request.getRemoteHost() %&gt; &lt;br&gt; HTTP头文件中User-Agent是:&lt;%=request.getHeader(&quot;User-Agent&quot;) %&gt; &lt;br&gt; HTTP头文件中accept的值是:&lt;%=request.getHeader(&quot;accept&quot;) %&gt; &lt;br&gt; HTTP头文件中Host的值是:&lt;%=request.getHeader(&quot;Host&quot;) %&gt; &lt;br&gt; HTTP头文件中accept-encoding的值是:&lt;%=request.getHeader(&quot;accept-encoding&quot;) %&gt; &lt;br&gt;头名字的一个枚举: &lt;% Enumeration en=request.getHeaderNames(); while(en.hasMoreElements()) out.println((String)en.nextElement()); %&gt; &lt;/body&gt;&lt;/html&gt; 2.response对象 客户端浏览器每访问一次Web服务器的页面都会提交一次请求，与request对象对应的是response对象，该对象可以用来对客户的请求做出响应，向客户端发送数据。输出的数据可以是各种数据类型，甚至是文件，这可以通过page指令的contentType属性或是response的**setContentType()**方法来设置。 response对象代表对客户端的响应，它实现了javax.servlet.ServletResponse接口。 常用方法 flushBuffer() 此方法强制将response缓冲区中的所有内容写到客户端。 1public void flushBuffer() throws IOException getBufferSize() 此方法得到response的实际缓冲区大小，单位为字节，如果没有使用缓冲区则返回0。 1public int getBufferSize() getCharacterEncoding() 此方法得到当前response中的字符集名称。 1public String getCharacterEncoding()(String name) getContentType() 此方法获得response中所发送的MIME类型。 1public String getContentType(String name) getOutputStream() 此方法返回一个可用于在response中写入二进制数据的输出流ServletOutputStream。在JSP页面中建议不使用这个方法，因为JSP页面中的数为文本数据。 1public ServletOutputStream getOutputStream() throws IOExceptionpublic getWriter() 此方法返回一个可用于在response中写入文本数据的PrintWriter对象。在JSP页面中建议不使用这个方法，因为它可能会影响Web容器的一些内在机制。 1public PrintWriter getWriter() throws IOException sendRedirect() 此方法用于进行页面重定向，参数location要导向目标地址，可以是相对路径也可以是绝对路径。 1public void sendRedirect()(String location) throws IOException setBufferSize() 此方法设置response的响应缓冲区大小(字节数)。 1public void setBufferSize() (int size) setCharacterEncoding() 此方法设置response的响应字符编码，也就是Content-Type中的charset属性值，此方法必须在调用getWriter()方法前调用。 1public void setCharacterEncoding() (String encoding) setContentType() 此方法设置response的Content-Type类型，如果其中包括了charset属性值，则会设置字符编码，此方法必须调用getWriter()方法前调用。 1public void setContentType() (String type) 使用Cookie Cookie是服务器发送给客户端浏览器的体积较小的纯文本信息，以后当用户访问同一个Web服务器时，浏览器会把它们发送给服务器。通过让服务器读取原先保存在客户端的信息，为浏览者提供一系列的方便。列如在线交易过程中标识用户身份，在安全要求不高的场合可避免用户重复输入名字和密码、门户网站的主页定制、有针对性的投放广告等。 使用Cookie可以为用户带来方便，但在安全性要求较高的场合下，建议不要使用Cookie。此外，浏览器中只允许存放300个Cookie，每个站点最多存放20个Cookie，每个Cookie的大小限制为4KB，故不必担心Cookie会过多地占用硬盘的空间。 Cookie存放在客户端，首先要新建一个Cookie，然后设置其属性，在通过response对象的addCookie()方法将其放入客户端，获取Cookie对象可调用request对象的getcookies()方法 1.创建Cookie 调用Cookie对象的构造函数可以创建Cookie： Cookie(String cookieName,String cookieValue) 在函数中，第一个参数cookieName是新建的Cookie对象的名称，第二个参数cookieValue是新建的Cookie对象的值。 2.设置与读取Cookie属性 在把Cookie加入待发送的应答头之前，可以查看或设置Cookie的各种属性。 getComment()/setComment():获取/设置Cookie的注释 getDomain()/setDomain():获取/设置Cookie适用的域 getMaxAge()/setMaxAge():获取/设置Cookie过期之前的时间，以秒计。 getName()/setName():获取/设置Cookie的名称。 getPath()/setPath():获取/设置Cookie适用的路径。 getSecure()/setSecure():获取/设置一个boolean值，该值表示Cookie是否只能通过加密的连接(即SSL)发送。 getValue()/setValue():获取/设置Cookie的值。 getVersion()/setVersion():获取/设置Cookie所遵从的协议版本。 3.将Cookie加入HTTP头中 可将addCookie()方法加入到Set-Cookie应答头 12Cookie cookie=new Cookie(&quot;usernam&quot;,&quot;dzycsai&quot;);response.addCookie(cookie); 4.读取Cookie** 从客户端读取Cookie时调用的是request对象的getCookies()方法。该方法返回一个与HTTP请求头中的内容对应Cookie对象数组。得到这个数组之后，一般是用循环语句访问其中的各个元素，并调用getName()检查各个Cookie的名字，直至找到目标Cookie为止；然后对这个目标Cookie调用getValue()，根据获得的结果进行其他处理。 response对象重定向 在JSP程序设计中，经常要进行页面的重定向，如在页面程序中加入判断语句即满足条件就转向某页面，不满足条件则转向另一个页面。代码演示: 1234567891011121314&lt;body&gt; &lt;% String url; url=request.getParameter(&quot;sle&quot;); if(url!=null) response.sendRedirect(url); %&gt; &lt;form name=&quot;fo&quot; action=&quot;url.jsp&quot; method=&quot;post&quot;&gt; &lt;select name=&quot;sle&quot; onchange=&quot;javascript:fo.submit()&quot;&gt; &lt;option value=&quot; &quot;&gt;===请选择===&lt;/option&gt; &lt;option value=&quot;lg-sheng.github.io&quot;&gt;LGS&lt;/option&gt; &lt;option value=&quot;www.baidu.com&quot;&gt;百度&lt;/option&gt; &lt;/select&gt; &lt;/form&gt; &lt;/body&gt; 定时刷新页面12345&lt;body&gt; &lt;% response.setHeader(&quot;refresh&quot;,&quot;1&quot;); %&gt; 当前的系统时间是: &lt;%out.println(new Date()); %&gt; &lt;/body&gt; session对象 session对象用来保存一些在与每个用户会话期间需要保持的数据信息，这样就方便了会话期间的一些处理程序。如可以用session变量记住用户的用户名，以后就不必在其他的网页中重复输入了。session对象的信息保存在服务器中，但ID保存在客户机的Cookie中。如果客户机不支持Cookie则转为URL重写，一般在使用session对象时不必考虑其实现的细节问题。 当用户关闭了所有某个Web服务器上的网页时，则此服务器与客户机的session对象以及其变量会自动消失。 常用方法 getAttribute() 此方法得到会话中指定的名称name相关对象，如果找不到则返回null。 1public Object getAttribute(Satring name) getAttributeNames() 此方法返回会话中所有对象名称的枚举。 1public java.util.Enumeration getAttributeNames() getMaxInactiveInterval() 此方法客户端会话有效时间间隔，即如果客户在网站上什么事也不做还能保持会话有效的时间间隔，单位为妙。 1public int getMaxInactiveInterval() getServletContext() 此方法返回当前会话所属的ServletContext。 1public javax.servlet.ServletContext getServletContext() invalidate() 此方法使当前会话失效。 1public void invalidate() isNew() 此方法如果服务器端尚未接受过客户端当前会话的请示，则此方法返回true，否则返回false。 1public boolean isNew() removeAttribure() 此方法删除会话中指定名称name所代表的对象。 1public void removeAttribure(String name) setMaxInactiveInterval() 此方法设置会话有效的时间间隔，即如果客户在网站上什么事也不做还能保持会话的有效时间间隔，单位为秒。 1public void setMaxInactiveInterval() 简单演示sessionLogin.jsp 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061&lt;%@ page language=&quot;java&quot; import=&quot;java.util.*&quot; pageEncoding=&quot;gb2312&quot;%&gt;&lt;%String path = request.getContextPath();String basePath = request.getScheme()+&quot;://&quot;+request.getServerName()+&quot;:&quot;+request.getServerPort()+path+&quot;/&quot;;%&gt;&lt;!DOCTYPE HTML PUBLIC &quot;-//W3C//DTD HTML 4.01 Transitional//EN&quot;&gt; &lt;%! public String codeToString(String str){ String s=str; try{ byte temp[]=s.getBytes(&quot;ISO-8859-1&quot;); s=new String(temp); return s; }catch (Exception e){ return s; }} %&gt; &lt;% String username=request.getParameter(&quot;username&quot;); String userpassword=request.getParameter(&quot;userpassword&quot;); if(username!=null&amp;&amp;userpassword!=null){ session.setAttribute(&quot;username&quot;,codeToString(username)); response.sendRedirect(&quot;sessionUserLogin1.jsp&quot;); } %&gt;&lt;html&gt; &lt;head&gt; &lt;title&gt;用户登入&lt;/title&gt; &lt;script type=&quot;text/javascript&quot;&gt; function on_submit(){ if(fo.username.value==&quot;&quot;){ alert(&quot;用户名不能为空。&quot;); fo.username.focus(); return false; } if(fo.userpassword.value==&quot;&quot;){ alert(&quot;密码不能为空。&quot;); fo.userpassword.focus(); return false; } } &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;table aligin=&quot;center&quot;&gt; &lt;form name=&quot;fo&quot; method=&quot;post&quot; action=&quot;sessionLogin.jsp&quot; onsubmit=&quot;return on_submit()&quot;&gt; &lt;tr aligin=&quot;center&quot;&gt;&lt;td&gt;用户登录&lt;/td&gt;&lt;/tr&gt; &lt;tr aligin=&quot;center&quot;&gt;&lt;td&gt;请输入用户名:&lt;input type=&quot;text&quot; name=&quot;username&quot; size=&quot;20&quot;&gt;&lt;/td&gt;&lt;/tr&gt; &lt;tr aligin=&quot;center&quot;&gt;&lt;td&gt;请输入密码: &amp;nbsp;&amp;nbsp;&lt;input type=&quot;password&quot; name=&quot;userpassword&quot; size=&quot;20&quot;&gt;&lt;/td&gt;&lt;/tr&gt; &lt;tr aligin=&quot;center&quot;&gt; &lt;td&gt; &lt;input type=&quot;submit&quot; value=&quot;提交&quot; name=&quot;B1&quot;&gt; &lt;input type=&quot;reset&quot; value=&quot;全部重写&quot; name=&quot;B2&quot;&gt; &lt;/td&gt; &lt;/tr&gt; &lt;/form&gt; &lt;/table&gt; &lt;/body&gt;&lt;/html&gt; sessionUserLogin1.jsp 1234567891011121314151617&lt;%@ page language=&quot;java&quot; import=&quot;java.util.*&quot; pageEncoding=&quot;gb2312&quot;%&gt;&lt;%String path = request.getContextPath();String basePath = request.getScheme()+&quot;://&quot;+request.getServerName()+&quot;:&quot;+request.getServerPort()+path+&quot;/&quot;;%&gt;&lt;!DOCTYPE HTML PUBLIC &quot;-//W3C//DTD HTML 4.01 Transitional//EN&quot;&gt;&lt;html&gt; &lt;head&gt; &lt;title&gt;登录成功&lt;/title&gt; &lt;/head&gt; &lt;body&gt; 登录成功&lt;br&gt; 你的用户名是:&lt;%=(String)session.getAttribute(&quot;username&quot;) %&gt; &lt;/body&gt;&lt;/html&gt; application对象 application对象用来在多个程序或者是多个用户之间共享数据，用户使用的所有application对象都是一样的，这与session对象不同。服务器一旦启动，就会自动创建application对象，并一直保持下去，直至服务器关闭，而application会自动消失。 常用方法 getAttribute() 此方法得到Servlet上下文属性name所代表的对象，如果没有找到则返回null。。 1public Object getAttribute(String name) getAttributeNames() 此方法得到Servlet上下文属性所有名称的枚举。 1public java.util.Enumeration getAttributeNames() getContext() 此方法得到指定URI相应的Servlet上下对象ServletContext，参数urlpath为URI，必须是绝对路径,即”/“开头。 1public ServletContext getContext(String urlpath) getInitParameter() 此方法返回一个String，值为指定的当前Web应用上下文配置name值，如果参数不存在则返回null。Web应用上下文配置参数可以在Web应用部署描述文件web.xml中进行定义，这个文件位于Web应用的WEB-INF子目录中。 1public String getInitParameter(String name) getInitParameterName() 此方法将当前Web应用上下文的配置参数作为一个枚举返回。 1public java.util.Enumeration getInitParameterName() getRealPath() 此方法返回path所对应的全路径。如果无法解释为一个文件系统全路径(如path中的文件由WAR文件给出)则返回null。 1public String getRealPath(String path) getServletContextName() 此方法得到当前Web应用描述文件中&lt; display-name &gt;元素所定义的上下文名称。 1public String getServletContextName() removeAttribute() 此方法删除Servlet上下文中指定的属性name所代表的对象。 1public void removeAttribute(String name) setAttribute() 此方法将Servlet上下文中指定的名称name所代表的对象设为attribute，如果name已存在则替换为attribute，如果不存在则创建一个。 1public void setAttribute(String name,Object attribute) 简单演示 网站计数器 12345678910111213141516171819202122232425262728293031323334&lt;%@ page language=&quot;java&quot; import=&quot;java.util.*&quot; pageEncoding=&quot;gb2312&quot;%&gt;&lt;%String path = request.getContextPath();String basePath = request.getScheme()+&quot;://&quot;+request.getServerName()+&quot;:&quot;+request.getServerPort()+path+&quot;/&quot;;%&gt;&lt;!DOCTYPE HTML PUBLIC &quot;-//W3C//DTD HTML 4.01 Transitional//EN&quot;&gt;&lt;html&gt; &lt;head&gt; &lt;title&gt;网页计数器&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;%! synchronized void countPeople(){ ServletContext application=((HttpServlet)(this)).getServletContext(); Integer number=(Integer)application.getAttribute(&quot;Count&quot;); if(number==null){ number=new Integer(1); application.setAttribute(&quot;Count&quot;,number); }else{ number=new Integer(number.intValue()+1); application.setAttribute(&quot;Count&quot;,number); } } %&gt; &lt;% if(session.isNew()) countPeople(); Integer yourNumber=(Integer)application.getAttribute(&quot;Count&quot;); %&gt; 欢迎访问本站，你是第&lt;%=yourNumber %&gt;个访问的用户。&lt;br&gt; &lt;/body&gt;&lt;/html&gt; out对象 out对象用来向客户端输出数据，其最为常用的方法就是print()和println()方法。 out对象代表向客户端浏览器输出内容的输出对象，由Web容器指定为javax.servlet.jsp.JspWriter类的一个子类。javax.servlet.jsp.JspWriter类位于jsp-api.jar组件包中。 常用方法 clear() 此方法清空缓冲区中的内容，如果缓冲区已经刷新输出，则抛出一个IOException异常，以表示有些数据已被不可恢复地写至客户端。 1public void clear() throws java.io.IOException clearBuffer() 此方法清空输出缓冲区的内容，与clear()方法不同，如果缓冲区已经刷新输出，此方法并不抛出IOException异常，而是在清空缓冲区当前内容后返回。 1public void clearBuffer() throws java.io.IOException close() 此方法在刷新并输出JspWriter后将其关闭。如果在close()调用之后再调用flush()或writer()则会抛出一个IOException异常。 1public void close() throws java.io.IOException flush() 此方法将输出缓冲区中的当前内容刷新输出，如果是有Web应用中则表示缓冲区的内容会立即交付给客户端。 1public void flush() java.io.IOException getBufferSize() 此方法得到输出缓冲区的大小，单位为字节，如果无缓冲区则返回0。 1public int getBufferSize() isAutoFlush() 此方法是否设置为自动刷新输出缓冲区，是则返回true，否则返回false。 1public boolean isAutoFlush() print() 此方法out对象的print()方法有许多种形式，主要用来在浏览器中输出数据。 123456789public void print(boolean arg) java.io.IOException;public void print(char arg) java.io.IOException;public void print(char[ ] arg) java.io.IOException;public void print(double arg) java.io.IOException;public void print(float arg) java.io.IOException;public void print(int arg) java.io.IOException;public void print(Object arg) java.io.IOException;public void print(String arg) java.io.IOException;public void print(long arg) java.io.IOException;","link":"/2019/05/05/JSP%E5%86%85%E7%BD%AE%E5%AF%B9%E8%B1%A1/"}],"tags":[],"categories":[{"name":"Hibernate","slug":"Hibernate","link":"/categories/Hibernate/"},{"name":"JDBC","slug":"JDBC","link":"/categories/JDBC/"},{"name":"JSP","slug":"JSP","link":"/categories/JSP/"},{"name":"深度学习","slug":"深度学习","link":"/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"},{"name":"SQL","slug":"SQL","link":"/categories/SQL/"},{"name":"Spring","slug":"Spring","link":"/categories/Spring/"},{"name":"Android","slug":"Android","link":"/categories/Android/"},{"name":"数据结构","slug":"数据结构","link":"/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"笔记","slug":"笔记","link":"/categories/%E7%AC%94%E8%AE%B0/"},{"name":"算法","slug":"算法","link":"/categories/%E7%AE%97%E6%B3%95/"}]}